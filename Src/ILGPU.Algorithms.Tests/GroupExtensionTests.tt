<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="Generic/ConfigurationBase.tt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>

using ILGPU.Algorithms.ScanReduceOperations;
using ILGPU.Runtime;
using ILGPU.Tests;
using System;
using System.Linq;
using Xunit;
using Xunit.Abstractions;

#pragma warning disable xUnit1026 

namespace ILGPU.Algorithms.Tests
{
    public abstract partial class GroupExtensionTests : TestBase
    {
        protected GroupExtensionTests(ITestOutputHelper output, TestContext testContext)
            : base(output, testContext)
        { }

<#
        var types = AtomicNumericTypes;
        int[] fractions = { 1, 2, 4 };
#>
        #region Kernel implementation

<#
        foreach (var func in WarpFunctions) {
#>
        internal static void <#= func #>Kernel<T, TFunction>(
            ArrayView<T> input,
            ArrayView<T> output)
            where T : unmanaged
            where TFunction : struct, IScanReduceOperation<T>
        {
            var globalIndex = Grid.GlobalIndex.X;

            output[globalIndex] = GroupExtensions.<#= func #><T, TFunction>(
                input[globalIndex]);
        }

<#
        }
#>
        #endregion

        #region MemberData
<#
        foreach (var srOp in ScanReduceOperations) {
#>
        public static TheoryData< object, object, object, object, object, object>
            <#= srOp.Name #>TestData =>
            new TheoryData< object, object, object, object, object, object>
        {
            // Type, ScanReduceOperation, Sequencer, Start of Sequence,
            // StepSize of Sequence, Fraction of Size
<#
            foreach (var type in types) {
                foreach (var frac in fractions) {
#>
            { default(<#= type.Type #>), default(Xunit<#= srOp.Name #><#= type.Name #>),
                default(<#= type.Name #>TestSequencer), 0, 0, <#= frac #> },
            { default(<#= type.Type #>), default(Xunit<#= srOp.Name #><#= type.Name #>),
                default(<#= type.Name #>TestSequencer), 1, 0, <#= frac #> },
            { default(<#= type.Type #>), default(Xunit<#= srOp.Name #><#= type.Name #>),
                default(<#= type.Name #>TestSequencer), 0, 1, <#= frac #> },
<#
                if(type.IsUnsignedInt) { continue; }
#>
            { default(<#= type.Type #>), default(Xunit<#= srOp.Name #><#= type.Name #>),
                default(<#= type.Name #>TestSequencer), -1, 0, <#= frac #> },
            { default(<#= type.Type #>), default(Xunit<#= srOp.Name #><#= type.Name #>),
                default(<#= type.Name #>TestSequencer), 0, -1, <#= frac #> },
<#
                }
            }
#>
        };

<#
        }
#>
        #endregion

        [Theory]
        [MemberData(nameof(AddTestData))]
        [MemberData(nameof(MaxTestData))]
        [MemberData(nameof(MinTestData))]
        [KernelMethod(nameof(ReduceKernel))]
        public void Reduce<T, TFunction, TSequencer>(
            T _,
            TFunction func,
            TSequencer sequencer,
            T start,
            T stepSize,
            int fraction)
            where T : unmanaged
            where TFunction : unmanaged, IScanReduceOperation<T>
            where TSequencer : struct, ITestSequencer<T>
        {
            var size = Math.Max(Accelerator.MaxNumThreadsPerGroup / fraction, 1);
            using var input = Accelerator.Allocate<T>(size);
            using var output = Accelerator.Allocate<T>(size);
            using var stream = Accelerator.CreateStream();

            input.CopyFrom(
                stream,
                sequencer.ComputeSequence(start, stepSize, size),
                0,
                0,
                size);
            stream.Synchronize();
            
            Execute<KernelConfig, T, TFunction>((1, size), input.View, output.View);

            T expected = CalcValue(input, func);
            T actual = output.GetAsArray()[0];
            Assert.Equal(expected, actual);
        }

        [Theory]
        [MemberData(nameof(AddTestData))]
        [MemberData(nameof(MaxTestData))]
        [MemberData(nameof(MinTestData))]
        [KernelMethod(nameof(AllReduceKernel))]
        public void AllReduce<T, TFunction, TSequencer>(
            T _,
            TFunction func,
            TSequencer sequencer,
            T start,
            T stepSize,
            int fraction)
            where T : unmanaged
            where TFunction : unmanaged, IScanReduceOperation<T>
            where TSequencer : struct, ITestSequencer<T>
        {
            var size = Math.Max(Accelerator.MaxNumThreadsPerGroup / fraction, 1);
            using var input = Accelerator.Allocate<T>(size);
            using var output = Accelerator.Allocate<T>(size);
            using var stream = Accelerator.CreateStream();

            input.CopyFrom(
                stream,
                sequencer.ComputeSequence(start, stepSize, size),
                0,
                0,
                size);
            stream.Synchronize();
            
            Execute<KernelConfig, T, TFunction>((1, size), input.View, output.View);
            
            var expected = Enumerable.Repeat(CalcValue(input, func), size).ToArray();
            Verify(output, expected);
        }

        [Theory]
        [MemberData(nameof(AddTestData))]
        [KernelMethod(nameof(ExclusiveScanKernel))]
        public void ExclusiveScanAdd<T, TFunction, TSequencer>(
            T _,
            TFunction func,
            TSequencer sequencer,
            T start,
            T stepSize,
            int fraction)
            where T : unmanaged
            where TFunction : unmanaged, IScanReduceOperation<T>
            where TSequencer : struct, ITestSequencer<T>
        {
            var size = Math.Max(Accelerator.MaxNumThreadsPerGroup / fraction, 1);
            using var input = Accelerator.Allocate<T>(size);
            using var output = Accelerator.Allocate<T>(size);
            using var stream = Accelerator.CreateStream();

            input.CopyFrom(
                stream,
                sequencer.ComputeSequence(start, stepSize, size),
                0,
                0,
                size);
            stream.Synchronize();
            
            Execute<KernelConfig, T, TFunction>((1, size), input.View, output.View);

            T[] expected = CalcValues(input, func, ScanKind.Exclusive);
            Verify(output, expected);
        }

        [Theory]
        [MemberData(nameof(MaxTestData))]
        [MemberData(nameof(MinTestData))]
        [KernelMethod(nameof(ExclusiveScanKernel))]
        public void ExclusiveScanMaxMin<T, TFunction, TSequencer>(
            T _,
            TFunction func,
            TSequencer sequencer,
            T start,
            T stepSize,
            int fraction)
            where T : unmanaged
            where TFunction : unmanaged, IScanReduceOperation<T>
            where TSequencer : struct, ITestSequencer<T>
        {
            var size = Math.Max(Accelerator.MaxNumThreadsPerGroup / fraction, 1);
            using var input = Accelerator.Allocate<T>(size);
            using var output = Accelerator.Allocate<T>(size);
            using var stream = Accelerator.CreateStream();

            input.CopyFrom(
                stream,
                sequencer.ComputeSequence(start, stepSize, size),
                0,
                0,
                size);
            stream.Synchronize();
            
            Execute<KernelConfig, T, TFunction>((1, size), input.View, output.View);

            T[] expected = CalcValues(input, func, ScanKind.Exclusive);
            Verify(output, expected, 1);
        }

        [Theory]
        [MemberData(nameof(AddTestData))]
        [MemberData(nameof(MaxTestData))]
        [MemberData(nameof(MinTestData))]
        [KernelMethod(nameof(InclusiveScanKernel))]
        public void InclusiveScan<T, TFunction, TSequencer>(
            T _,
            TFunction func,
            TSequencer sequencer,
            T start,
            T stepSize,
            int fraction)
            where T : unmanaged
            where TFunction : unmanaged, IScanReduceOperation<T>
            where TSequencer : struct, ITestSequencer<T>
        {
            var size = Math.Max(Accelerator.MaxNumThreadsPerGroup / fraction, 1);
            using var input = Accelerator.Allocate<T>(size);
            using var output = Accelerator.Allocate<T>(size);
            using var stream = Accelerator.CreateStream();

            input.CopyFrom(
                stream,
                sequencer.ComputeSequence(start, stepSize, size),
                0,
                0,
                size);
            stream.Synchronize();
            
            Execute<KernelConfig, T, TFunction>((1, size), input.View, output.View);
            
            T[] expected = CalcValues(input, func, ScanKind.Inclusive);
            Verify(output, expected);
        }
        
        #region Helper Methods

        private T CalcValue<T, TFunction>(MemoryBuffer<T> buffer, TFunction func)
            where T : unmanaged
            where TFunction : struct, IScanReduceOperation<T>
        {
            using var stream = Accelerator.CreateStream();
            var values = buffer.GetAsArray(stream);
            stream.Synchronize();
            
            T result = values[0];
            for (int i = 1, e = values.Length; i < e; ++i)
                result = func.Apply(result, values[i]);
            return result;
        }

        private T[] CalcValues<T, TFunction>(
            MemoryBuffer<T> buffer,
            TFunction func,
            ScanKind kind)
            where T : unmanaged
            where TFunction : struct, IScanReduceOperation<T>
        {
            using var stream = Accelerator.CreateStream();
            var values = buffer.GetAsArray(stream);
            stream.Synchronize();

            T[] result = new T[values.Length];
            result[0] = values[0];

            for (int i = 1, e = values.Length; i < e; ++i)
                result[i] = func.Apply(result[i-1], values[i]);

            if (kind == ScanKind.Exclusive)
            {
                T[] zero = { default }; 
                result = zero.Concat(result.Take(result.Length - 1)).ToArray();
            }
            return result;
        }

        #endregion
    }
}

#pragma warning restore xUnit1026 // Theory methods should use all of their parameters