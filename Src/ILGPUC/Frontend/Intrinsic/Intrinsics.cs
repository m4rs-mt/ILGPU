// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2018-2025 ILGPU Project
//                                    www.ilgpu.net
//
// File: Intrinsics.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

using ILGPU.Intrinsic;
using ILGPU.Util;
using ILGPUC.Backends;
using ILGPUC.IR;
using ILGPUC.IR.Values;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

// disable: max_line_length

namespace ILGPUC.Frontend.Intrinsic;

/// <summary>
/// Represents implementation possibilities of an intrinsic method.
/// </summary>
enum IntrinsicImplementationKind
{
    /// <summary>
    /// No intrinsic method.
    /// </summary>
    None,

    /// <summary>
    /// Will be remapped to a different implementation.
    /// </summary>
    Remapped,

    /// <summary>
    /// Will be implemented by another method internally.
    /// </summary>
    Implemented,

    /// <summary>
    /// Will be code generated by an intrinsic code generator.
    /// </summary>
    Generated,
}

/// <summary>
/// Contains default ILGPU intrinsics.
/// </summary>
static unsafe partial class Intrinsics
{
    #region Constants

    const BindingFlags DefaultBindingFlags =
        BindingFlags.Instance | BindingFlags.CreateInstance | BindingFlags.Static |
        BindingFlags.Public | BindingFlags.NonPublic;
    public const BindingFlags RemapBindingFlags = DefaultBindingFlags;
    public const BindingFlags GeneratorBindingFlags = DefaultBindingFlags;

    #endregion

    #region Nested Types

    /// <summary>
    /// Method lookup helper class to retrieve methods by name and number of arguments.
    /// </summary>
    readonly struct MethodLookup
    {
        private readonly Dictionary<string, List<MethodBase>> _lookup;
        private readonly Dictionary<(string, int), List<MethodBase>> _paramLookup;

        /// <summary>
        /// Creates a new method lookup for the given type.
        /// </summary>
        /// <param name="type">The type to create the lookup for.</param>
        /// <param name="bindingFlags">Binding flags to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveOptimization)]
        public MethodLookup(Type type, BindingFlags bindingFlags)
        {
            var methods = type.GetMethods(bindingFlags);
            var constructors = type.GetConstructors(bindingFlags);
            var combined = methods.Cast<MethodBase>()
                .Concat(constructors.Cast<MethodBase>())
                .ToArray();
            _lookup = new(combined.Length);
            _paramLookup = new(combined.Length);
            foreach (var method in combined)
            {
                if (_lookup.TryGetValue(method.Name, out var value))
                    value.Add(method);
                else
                    _lookup.Add(method.Name, [method]);

                var paramKey = (method.Name, method.GetParameters().Length);
                if (_paramLookup.TryGetValue(paramKey, out value))
                    value.Add(method);
                else
                    _paramLookup.Add(paramKey, [method]);
            }
        }

        public IReadOnlyList<MethodBase> this[string name] => _lookup[name];
        public IReadOnlyList<MethodBase> this[string name, int numArguments] =>
            _paramLookup[(name, numArguments)];
    }

    /// <summary>
    /// Implements a backend-mapping allowing for efficient lookups of backend methods.
    /// </summary>
    /// <typeparam name="T">The mapping type.</typeparam>
    /// <param name="ptx">The PTX backend implementation.</param>
    readonly struct BackendMap<T>(T ptx)
    {
        private readonly T[] _data = [ptx];

        public T this[BackendType backendType] => _data[(int)backendType];
    }

    /// <summary>
    /// A generic context to instantiate specialized internal methods.
    /// </summary>
    /// <param name="Source">The source method.</param>
    /// <param name="GenericMethodArgs">Generic method type arguments.</param>
    /// <param name="GenericTypeArgs">Generic declaring type arguments.</param>
    internal readonly struct GenericContext(
        MethodBase Source,
        Type[] GenericMethodArgs,
        Type[] GenericTypeArgs)
    {
        /// <summary>
        /// Tries to get a new generic context from the given method.
        /// </summary>
        /// <param name="method">The method to get a new context for.</param>
        /// <returns>The generic context if this method has one.</returns>
        public static GenericContext? TryGet(MethodBase method)
        {
            Type[] genericMethodArgs;
            Type? genericType;

            // Check for generic methods
            if (method is MethodInfo methodInfo)
            {
                if (methodInfo.IsGenericMethod)
                {
                    // Determine generic method and get generic args and type
                    genericMethodArgs = methodInfo.GetGenericArguments();
                    var genericMethod = methodInfo.GetGenericMethodDefinition();
                    genericType = genericMethod.DeclaringType;
                }
                else
                {
                    // Get generic type directly from method
                    genericMethodArgs = [];
                    genericType = method.DeclaringType;
                }
            }
            // Check for constructors of generic types
            else if (method is ConstructorInfo constructorInfo)
            {
                // Constructors do not have generic type parameters
                genericMethodArgs = [];
                genericType = constructorInfo.DeclaringType;
            }
            else
            {
                // This cannot be reached
                throw new UnreachableException();
            }

            var genericTypeArgs = genericType?.IsGenericType ?? false
                ? genericType.GetGenericArguments()
                : [];
            return genericMethodArgs.Length > 0 || genericTypeArgs.Length > 0
                ? new(method, genericMethodArgs, genericTypeArgs)
                : null;
        }

        /// <summary>
        /// Finds a member using internal metadata token resolvers.
        /// </summary>
        private T Find<T>(T[] members) where T : MemberInfo
        {
            foreach (var member in members)
            {
                if (member.MetadataToken == Source.MetadataToken)
                    return member;
            }

            throw new UnreachableException();
        }

        /// <summary>
        /// Gets a specialized method based on the given one to ensure we are using the
        /// right instantiation with all declaring types.
        /// </summary>
        /// <param name="method">The method to specialize.</param>
        /// <returns>The specialized method.</returns>
        public MethodBase GetSpecializedMethod(MethodBase method)
        {
            if (method is MethodInfo methodInfo)
            {
                if (GenericTypeArgs.Length < 1)
                    return methodInfo.MakeGenericMethod(GenericMethodArgs);

                var methodDeclarationType = methodInfo.DeclaringType
                    .AsNotNull()
                    .MakeGenericType(GenericTypeArgs);
                var genericMethod = Find(
                    methodDeclarationType.GetMethods(GeneratorBindingFlags))
                    .AsNotNullCast<MethodInfo>();

                return GenericMethodArgs.Length < 1
                    ? genericMethod
                    : genericMethod.MakeGenericMethod(GenericMethodArgs);
            }

            Debug.Assert(method is ConstructorInfo);
            var constructorDeclarationType = Source.DeclaringType
                .AsNotNull()
                .MakeGenericType(GenericTypeArgs);
            var genericConstructor = Find(
                constructorDeclarationType.GetConstructors(GeneratorBindingFlags));
            Debug.Assert(GenericMethodArgs.Length == 0);
            return genericConstructor;
        }
    }

    #endregion

    #region Intrinsic Generators

    /// <summary>
    /// Intrinsic generator delegate to implement intrinsic operations on the IR level.
    /// </summary>
    /// <param name="context">The current context.</param>
    /// <returns>The value reference return.</returns>
    delegate ValueReference IntrinsicGenerator(ref InvocationContext context);

    #endregion

    /// <summary>
    /// Intrinsics initialization.
    /// </summary>
    static Intrinsics()
    {
        InitializeRemapping();
        InitializeGeneration();
        InitializeBackendImplementations();
    }

    /// <summary>
    /// Triggers implicit initialization.
    /// </summary>
    public static void Init() { }

    /// <summary>
    /// Returns true if the given method is an ILGPU intrinsic function.
    /// </summary>
    /// <param name="method">The method to test.</param>
    /// <returns>True if the given method is an ILGPU intrinsic function.</returns>
    public static bool IsILGPUIntrinsic(this MethodBase method) =>
        method.GetCustomAttribute<IntrinsicAttribute>() is not null;

    /// <summary>
    /// Tries to remap the given method to an intrinsic implementation.
    /// </summary>
    /// <param name="location">The current location.</param>
    /// <param name="method">The method to be (potentially) remapped.</param>
    /// <param name="backendType">Current backend type.</param>
    /// <param name="remapped">The remapped method (if any).</param>
    /// <returns>Implementation kind of the given method.</returns>
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public static IntrinsicImplementationKind TryImplement(
        Location location,
        MethodBase method,
        BackendType backendType,
       out MethodBase? remapped)
    {
        // Find preliminary generic definition
        var genericContext = GenericContext.TryGet(method);

        // Determine whether the given method has an intrinsic remapping
        if (TryGetIntrinsicRemapping(method, out remapped))
        {
            remapped = genericContext?.GetSpecializedMethod(remapped) ?? remapped;
            return IntrinsicImplementationKind.Remapped;
        }

        // Try to get a backend implementation for this method
        if (TryGetIntrinsicImplementation(method, out var map))
        {
            remapped = map[backendType];
            remapped = genericContext?.GetSpecializedMethod(remapped) ?? remapped;
            return IntrinsicImplementationKind.Implemented;
        }

        // Ignore methods that are not known intrinsics
        if (!method.IsILGPUIntrinsic())
            return IntrinsicImplementationKind.None;

        // Sanity check existence of intrinsic handlers
        remapped = null;
        return HasIntrinsicGenerator(method)
            ? IntrinsicImplementationKind.Generated
            : throw location.GetInvalidOperationException();
    }

    /// <summary>
    /// Tries to generate code for a specific invocation context. This method
    /// can generate custom code instead of default method-invocation flow.
    /// </summary>
    /// <param name="context">The current invocation context.</param>
    /// <param name="result">The resulting value of the intrinsic call.</param>
    /// <returns>True if this call could handle the call.</returns>
    public static bool TryGenerateCode(
        ref InvocationContext context,
        out ValueReference result)
    {
        result = default;
        var method = context.Method;

        // Remappings are not supported by this method and need to be handled upfront
        if (HasIntrinsicRemapping(method))
            throw context.Location.GetInvalidOperationException();

        // Check for immediate code generators and backend implementations
        if (TryGetIntrinsicGenerator(method, out var generator))
        {
            // Implement the intrinsic
            result = generator(ref context);
            return true;
        }

        return false;
    }
}
