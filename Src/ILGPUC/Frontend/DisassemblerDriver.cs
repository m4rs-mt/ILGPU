// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2018-2025 ILGPU Project
//                                    www.ilgpu.net
//
// File: DisassemblerDriver.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using ILGPUC.Util;
using System.Diagnostics.CodeAnalysis;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;

// disable: max_line_length

namespace ILGPUC.Frontend
{
    partial class Disassembler
    {
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private bool TryDisassembleInstruction(ILOpCode opCode)
        {
            switch (opCode)
            {
                // Misc
                case ILOpCode.Nop:
                    AppendInstruction(ILInstructionType.Nop);
                    return true;
                case ILOpCode.Break:
                    AppendInstruction(ILInstructionType.Break);
                    return true;

                // Arguments
                case ILOpCode.Ldarg_0:
                    AppendInstruction(ILInstructionType.Ldarg, 0);
                    return true;
                case ILOpCode.Ldarg_1:
                    AppendInstruction(ILInstructionType.Ldarg, 1);
                    return true;
                case ILOpCode.Ldarg_2:
                    AppendInstruction(ILInstructionType.Ldarg, 2);
                    return true;
                case ILOpCode.Ldarg_3:
                    AppendInstruction(ILInstructionType.Ldarg, 3);
                    return true;
                case ILOpCode.Ldarg_S:
                    AppendInstruction(ILInstructionType.Ldarg, ReadByteArg());
                    return true;
                case ILOpCode.Ldarg:
                    AppendInstruction(ILInstructionType.Ldarg, ReadUShortArg());
                    return true;
                case ILOpCode.Ldarga_S:
                    AppendInstruction(ILInstructionType.Ldarga, ReadByteArg());
                    return true;
                case ILOpCode.Ldarga:
                    AppendInstruction(ILInstructionType.Ldarga, ReadUShortArg());
                    return true;
                case ILOpCode.Starg_S:
                    AppendInstruction(ILInstructionType.Starg, ReadByteArg());
                    return true;
                case ILOpCode.Starg:
                    AppendInstruction(ILInstructionType.Starg, ReadUShortArg());
                    return true;

                // Locals
                case ILOpCode.Ldloc_0:
                    AppendInstruction(ILInstructionType.Ldloc, 0);
                    return true;
                case ILOpCode.Ldloc_1:
                    AppendInstruction(ILInstructionType.Ldloc, 1);
                    return true;
                case ILOpCode.Ldloc_2:
                    AppendInstruction(ILInstructionType.Ldloc, 2);
                    return true;
                case ILOpCode.Ldloc_3:
                    AppendInstruction(ILInstructionType.Ldloc, 3);
                    return true;
                case ILOpCode.Ldloc_S:
                    AppendInstruction(ILInstructionType.Ldloc, ReadByteArg());
                    return true;
                case ILOpCode.Ldloc:
                    AppendInstruction(ILInstructionType.Ldloc, ReadUShortArg());
                    return true;
                case ILOpCode.Ldloca_S:
                    AppendInstruction(ILInstructionType.Ldloca, ReadByteArg());
                    return true;
                case ILOpCode.Ldloca:
                    AppendInstruction(ILInstructionType.Ldloca, ReadUShortArg());
                    return true;
                case ILOpCode.Stloc_0:
                    AppendInstruction(ILInstructionType.Stloc, 0);
                    return true;
                case ILOpCode.Stloc_1:
                    AppendInstruction(ILInstructionType.Stloc, 1);
                    return true;
                case ILOpCode.Stloc_2:
                    AppendInstruction(ILInstructionType.Stloc, 2);
                    return true;
                case ILOpCode.Stloc_3:
                    AppendInstruction(ILInstructionType.Stloc, 3);
                    return true;
                case ILOpCode.Stloc_S:
                    AppendInstruction(ILInstructionType.Stloc, ReadByteArg());
                    return true;
                case ILOpCode.Stloc:
                    AppendInstruction(ILInstructionType.Stloc, ReadUShortArg());
                    return true;

                // Constants
                case ILOpCode.Ldnull:
                    AppendInstruction(ILInstructionType.Ldnull);
                    return true;
                case ILOpCode.Ldc_I4_M1:
                    AppendInstruction(ILInstructionType.LdI4, -1);
                    return true;
                case ILOpCode.Ldc_I4_0:
                    AppendInstruction(ILInstructionType.LdI4, 0);
                    return true;
                case ILOpCode.Ldc_I4_1:
                    AppendInstruction(ILInstructionType.LdI4, 1);
                    return true;
                case ILOpCode.Ldc_I4_2:
                    AppendInstruction(ILInstructionType.LdI4, 2);
                    return true;
                case ILOpCode.Ldc_I4_3:
                    AppendInstruction(ILInstructionType.LdI4, 3);
                    return true;
                case ILOpCode.Ldc_I4_4:
                    AppendInstruction(ILInstructionType.LdI4, 4);
                    return true;
                case ILOpCode.Ldc_I4_5:
                    AppendInstruction(ILInstructionType.LdI4, 5);
                    return true;
                case ILOpCode.Ldc_I4_6:
                    AppendInstruction(ILInstructionType.LdI4, 6);
                    return true;
                case ILOpCode.Ldc_I4_7:
                    AppendInstruction(ILInstructionType.LdI4, 7);
                    return true;
                case ILOpCode.Ldc_I4_8:
                    AppendInstruction(ILInstructionType.LdI4, 8);
                    return true;
                case ILOpCode.Ldc_I4_S:
                    AppendInstruction(ILInstructionType.LdI4, ReadSByteArg());
                    return true;
                case ILOpCode.Ldc_I4:
                    AppendInstruction(ILInstructionType.LdI4, ReadIntArg());
                    return true;
                case ILOpCode.Ldc_I8:
                    AppendInstruction(ILInstructionType.LdI8, ReadLongArg());
                    return true;
                case ILOpCode.Ldc_R4:
                    AppendInstruction(ILInstructionType.LdR4, ReadSingleArg());
                    return true;
                case ILOpCode.Ldc_R8:
                    AppendInstruction(ILInstructionType.LdR8, ReadDoubleArg());
                    return true;
                case ILOpCode.Ldstr:
                    AppendInstruction(ILInstructionType.Ldstr, AssociatedModule.ResolveString(ReadIntArg()));
                    return true;

                // Stack
                case ILOpCode.Dup:
                    AppendInstruction(ILInstructionType.Dup);
                    return true;
                case ILOpCode.Pop:
                    AppendInstruction(ILInstructionType.Pop);
                    return true;
                case ILOpCode.Jmp:
                    AppendInstruction(ILInstructionType.Jmp, ResolveMethod(ReadIntArg()));
                    return true;

                // Call
                case ILOpCode.Call:
                    DisassembleCall(ILInstructionType.Call, ReadIntArg());
                    return true;
                case ILOpCode.Calli:
                    DisassembleCall(ILInstructionType.Calli, ReadIntArg());
                    return true;
                case ILOpCode.Callvirt:
                    DisassembleCall(ILInstructionType.Callvirt, ReadIntArg());
                    return true;
                case ILOpCode.Ret:
                    AppendInstruction(ILInstructionType.Ret, MethodBase);
                    return true;

                // Branch
                case ILOpCode.Br_S:
                    AppendInstruction(ILInstructionType.Br, new ILInstructionBranchTargets(ReadShortBranchTarget()));
                    return true;
                case ILOpCode.Br:
                    AppendInstruction(ILInstructionType.Br, new ILInstructionBranchTargets(ReadBranchTarget()));
                    return true;
                case ILOpCode.Brfalse_S:
                    AppendInstruction(ILInstructionType.Brfalse, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Brfalse:
                    AppendInstruction(ILInstructionType.Brfalse, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Brtrue_S:
                    AppendInstruction(ILInstructionType.Brtrue, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Brtrue:
                    AppendInstruction(ILInstructionType.Brtrue, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Beq_S:
                    AppendInstruction(ILInstructionType.Beq, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Beq:
                    AppendInstruction(ILInstructionType.Beq, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bge_S:
                    AppendInstruction(ILInstructionType.Bge, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bge:
                    AppendInstruction(ILInstructionType.Bge, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bgt_S:
                    AppendInstruction(ILInstructionType.Bgt, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bgt:
                    AppendInstruction(ILInstructionType.Bgt, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Ble_S:
                    AppendInstruction(ILInstructionType.Ble, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Ble:
                    AppendInstruction(ILInstructionType.Ble, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Blt_S:
                    AppendInstruction(ILInstructionType.Blt, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Blt:
                    AppendInstruction(ILInstructionType.Blt, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bne_Un_S:
                    AppendInstructionWithFlags(ILInstructionType.Bne, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bne_Un:
                    AppendInstructionWithFlags(ILInstructionType.Bne, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bge_Un_S:
                    AppendInstructionWithFlags(ILInstructionType.Bge, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bge_Un:
                    AppendInstructionWithFlags(ILInstructionType.Bge, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bgt_Un_S:
                    AppendInstructionWithFlags(ILInstructionType.Bgt, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Bgt_Un:
                    AppendInstructionWithFlags(ILInstructionType.Bgt, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Ble_Un_S:
                    AppendInstructionWithFlags(ILInstructionType.Ble, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Ble_Un:
                    AppendInstructionWithFlags(ILInstructionType.Ble, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Blt_Un_S:
                    AppendInstructionWithFlags(ILInstructionType.Blt, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Blt_Un:
                    AppendInstructionWithFlags(ILInstructionType.Blt, ILInstructionFlags.Unsigned, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Switch:
                    {
                        uint numSwitchTargets = ReadUIntArg();
                        int[] switchTargets = new int[numSwitchTargets + 1];
                        var switchBaseOffset = switchTargets[0] = _ilOffset + sizeof(int) * (int)numSwitchTargets;
                        for (int i = 0, e = (int)numSwitchTargets; i < e; ++i)
                            switchTargets[i + 1] = switchBaseOffset + ReadIntArg();
                        AppendInstruction(ILInstructionType.Switch, new ILInstructionBranchTargets(switchTargets));
                    }
                    return true;

                // Arithmetic
                case ILOpCode.Add:
                    AppendInstructionWithFlags(ILInstructionType.Add, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Add_Ovf:
                    AppendInstructionWithFlags(ILInstructionType.Add, ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Add_Ovf_Un:
                    AppendInstructionWithFlags(ILInstructionType.Add, ILInstructionFlags.Unsigned | ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Sub:
                    AppendInstructionWithFlags(ILInstructionType.Sub, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Sub_Ovf:
                    AppendInstructionWithFlags(ILInstructionType.Sub, ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Sub_Ovf_Un:
                    AppendInstructionWithFlags(ILInstructionType.Sub, ILInstructionFlags.Unsigned | ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Mul:
                    AppendInstructionWithFlags(ILInstructionType.Mul, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Mul_Ovf:
                    AppendInstructionWithFlags(ILInstructionType.Mul, ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Mul_Ovf_Un:
                    AppendInstructionWithFlags(ILInstructionType.Mul, ILInstructionFlags.Unsigned | ILInstructionFlags.Overflow);
                    return true;
                case ILOpCode.Div:
                    AppendInstructionWithFlags(ILInstructionType.Div, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Div_Un:
                    AppendInstructionWithFlags(ILInstructionType.Div, ILInstructionFlags.Unsigned);
                    return true;
                case ILOpCode.Rem:
                    AppendInstructionWithFlags(ILInstructionType.Rem, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Rem_Un:
                    AppendInstructionWithFlags(ILInstructionType.Rem, ILInstructionFlags.Unsigned);
                    return true;
                case ILOpCode.And:
                    AppendInstructionWithFlags(ILInstructionType.And, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Or:
                    AppendInstructionWithFlags(ILInstructionType.Or, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Xor:
                    AppendInstructionWithFlags(ILInstructionType.Xor, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Shl:
                    AppendInstructionWithFlags(ILInstructionType.Shl, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Shr:
                    AppendInstructionWithFlags(ILInstructionType.Shr, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Shr_Un:
                    AppendInstructionWithFlags(ILInstructionType.Shr, ILInstructionFlags.Unsigned);
                    return true;
                case ILOpCode.Neg:
                    AppendInstructionWithFlags(ILInstructionType.Neg, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Not:
                    AppendInstructionWithFlags(ILInstructionType.Not, ILInstructionFlags.None);
                    return true;

                // Conversion
                case ILOpCode.Conv_I1:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(sbyte));
                    return true;
                case ILOpCode.Conv_I2:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(short));
                    return true;
                case ILOpCode.Conv_I4:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(int));
                    return true;
                case ILOpCode.Conv_I8:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(long));
                    return true;
                case ILOpCode.Conv_I:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, NativePtrType);
                    return true;
                case ILOpCode.Conv_Ovf_I1:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(sbyte));
                    return true;
                case ILOpCode.Conv_Ovf_I2:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(short));
                    return true;
                case ILOpCode.Conv_Ovf_I4:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(int));
                    return true;
                case ILOpCode.Conv_Ovf_I8:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(long));
                    return true;
                case ILOpCode.Conv_Ovf_I:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, NativePtrType);
                    return true;
                case ILOpCode.Conv_Ovf_I1_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(sbyte));
                    return true;
                case ILOpCode.Conv_Ovf_I2_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(short));
                    return true;
                case ILOpCode.Conv_Ovf_I4_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(int));
                    return true;
                case ILOpCode.Conv_Ovf_I8_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(long));
                    return true;
                case ILOpCode.Conv_Ovf_I_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, NativePtrType);
                    return true;
                case ILOpCode.Conv_R4:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(float));
                    return true;
                case ILOpCode.Conv_R8:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(double));
                    return true;
                case ILOpCode.Conv_R_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Unsigned, ILInstruction.ConvRUnArguments);
                    return true;
                case ILOpCode.Conv_U1:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(byte));
                    return true;
                case ILOpCode.Conv_U2:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(ushort));
                    return true;
                case ILOpCode.Conv_U4:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(uint));
                    return true;
                case ILOpCode.Conv_U8:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, typeof(ulong));
                    return true;
                case ILOpCode.Conv_U:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.None, NativePtrType);
                    return true;
                case ILOpCode.Conv_Ovf_U1:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(byte));
                    return true;
                case ILOpCode.Conv_Ovf_U2:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(ushort));
                    return true;
                case ILOpCode.Conv_Ovf_U4:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(uint));
                    return true;
                case ILOpCode.Conv_Ovf_U8:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, typeof(ulong));
                    return true;
                case ILOpCode.Conv_Ovf_U:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow, NativePtrType);
                    return true;
                case ILOpCode.Conv_Ovf_U1_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(byte));
                    return true;
                case ILOpCode.Conv_Ovf_U2_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(ushort));
                    return true;
                case ILOpCode.Conv_Ovf_U4_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(uint));
                    return true;
                case ILOpCode.Conv_Ovf_U8_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, typeof(ulong));
                    return true;
                case ILOpCode.Conv_Ovf_U_Un:
                    AppendInstructionWithFlags(ILInstructionType.Conv, ILInstructionFlags.Overflow | ILInstructionFlags.Unsigned, NativePtrType);
                    return true;

                // General Objects
                case ILOpCode.Initobj:
                    AppendInstruction(ILInstructionType.Initobj, ReadTypeArg());
                    return true;
                case ILOpCode.Newobj:
                    DisassembleCall(ILInstructionType.Newobj, ReadIntArg());
                    return true;
                case ILOpCode.Newarr:
                    AppendInstruction(ILInstructionType.Newarr, ReadTypeArg());
                    return true;

                // Boxing
                case ILOpCode.Box:
                    AppendInstruction(ILInstructionType.Box, ReadTypeArg());
                    return true;
                case ILOpCode.Unbox:
                    AppendInstruction(ILInstructionType.Unbox, ReadTypeArg());
                    return true;
                case ILOpCode.Unbox_Any:
                    {
                        var type = ResolveType(ReadIntArg());
                        AppendInstruction(ILInstructionType.Unbox, type);
                        AppendInstruction(ILInstructionType.Ldobj, type);
                    }
                    return true;

                case ILOpCode.Castclass:
                    AppendInstruction(ILInstructionType.Castclass, ReadTypeArg());
                    return true;
                case ILOpCode.Isinst:
                    AppendInstruction(ILInstructionType.Isinst, ReadTypeArg());
                    return true;

                // Fields
                case ILOpCode.Ldfld:
                    AppendInstruction(ILInstructionType.Ldfld, ReadFieldArg());
                    return true;
                case ILOpCode.Ldflda:
                    AppendInstruction(ILInstructionType.Ldflda, ReadFieldArg());
                    return true;
                case ILOpCode.Ldsfld:
                    AppendInstruction(ILInstructionType.Ldsfld, ReadFieldArg());
                    return true;
                case ILOpCode.Ldsflda:
                    AppendInstruction(ILInstructionType.Ldsflda, ReadFieldArg());
                    return true;
                case ILOpCode.Stfld:
                    AppendInstruction(ILInstructionType.Stfld, ReadFieldArg());
                    return true;
                case ILOpCode.Stsfld:
                    AppendInstruction(ILInstructionType.Stsfld, ReadFieldArg());
                    return true;

                // Indirect Objects
                case ILOpCode.Ldobj:
                    AppendInstruction(ILInstructionType.Ldobj, ReadTypeArg());
                    return true;
                case ILOpCode.Stobj:
                    AppendInstruction(ILInstructionType.Stobj, ReadTypeArg());
                    return true;
                case ILOpCode.Cpobj:
                    AppendInstruction(ILInstructionType.Cpobj, ReadTypeArg());
                    return true;

                // Arrays
                case ILOpCode.Ldlen:
                    AppendInstruction(ILInstructionType.Ldlen);
                    return true;
                case ILOpCode.Ldelem_I1:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(sbyte));
                    return true;
                case ILOpCode.Ldelem_U1:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(byte));
                    return true;
                case ILOpCode.Ldelem_I2:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(short));
                    return true;
                case ILOpCode.Ldelem_U2:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(ushort));
                    return true;
                case ILOpCode.Ldelem_I4:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(int));
                    return true;
                case ILOpCode.Ldelem_U4:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(uint));
                    return true;
                case ILOpCode.Ldelem_I8:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(long));
                    return true;
                case ILOpCode.Ldelem_R4:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(float));
                    return true;
                case ILOpCode.Ldelem_R8:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(double));
                    return true;
                case ILOpCode.Ldelem_Ref:
                    AppendInstruction(ILInstructionType.Ldelem, typeof(object));
                    return true;
                case ILOpCode.Ldelem:
                    AppendInstruction(ILInstructionType.Ldelem, ReadTypeArg());
                    return true;
                case ILOpCode.Ldelem_I:
                    AppendInstruction(ILInstructionType.Ldelem, NativePtrType);
                    return true;
                case ILOpCode.Ldelema:
                    AppendInstruction(ILInstructionType.Ldelema, ReadTypeArg());
                    return true;
                case ILOpCode.Stelem_I1:
                    AppendInstruction(ILInstructionType.Stelem, typeof(sbyte));
                    return true;
                case ILOpCode.Stelem_I2:
                    AppendInstruction(ILInstructionType.Stelem, typeof(short));
                    return true;
                case ILOpCode.Stelem_I4:
                    AppendInstruction(ILInstructionType.Stelem, typeof(int));
                    return true;
                case ILOpCode.Stelem_I8:
                    AppendInstruction(ILInstructionType.Stelem, typeof(long));
                    return true;
                case ILOpCode.Stelem_R4:
                    AppendInstruction(ILInstructionType.Stelem, typeof(float));
                    return true;
                case ILOpCode.Stelem_R8:
                    AppendInstruction(ILInstructionType.Stelem, typeof(double));
                    return true;
                case ILOpCode.Stelem_I:
                    AppendInstruction(ILInstructionType.Stelem, NativePtrType);
                    return true;
                case ILOpCode.Stelem_Ref:
                    AppendInstruction(ILInstructionType.Stelem, typeof(object));
                    return true;
                case ILOpCode.Stelem:
                    AppendInstruction(ILInstructionType.Stelem, ReadTypeArg());
                    return true;

                // Compare
                case ILOpCode.Ceq:
                    AppendInstructionWithFlags(ILInstructionType.Ceq, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Cgt:
                    AppendInstructionWithFlags(ILInstructionType.Cgt, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Cgt_Un:
                    AppendInstructionWithFlags(ILInstructionType.Cgt, ILInstructionFlags.Unsigned);
                    return true;
                case ILOpCode.Clt:
                    AppendInstructionWithFlags(ILInstructionType.Clt, ILInstructionFlags.None);
                    return true;
                case ILOpCode.Clt_Un:
                    AppendInstructionWithFlags(ILInstructionType.Clt, ILInstructionFlags.Unsigned);
                    return true;

                // Indirect
                case ILOpCode.Ldind_I1:
                    AppendInstruction(ILInstructionType.Ldind, typeof(sbyte));
                    return true;
                case ILOpCode.Ldind_I2:
                    AppendInstruction(ILInstructionType.Ldind, typeof(short));
                    return true;
                case ILOpCode.Ldind_I4:
                    AppendInstruction(ILInstructionType.Ldind, typeof(int));
                    return true;
                case ILOpCode.Ldind_I8:
                    AppendInstruction(ILInstructionType.Ldind, typeof(long));
                    return true;
                case ILOpCode.Ldind_U1:
                    AppendInstruction(ILInstructionType.Ldind, typeof(byte));
                    return true;
                case ILOpCode.Ldind_U2:
                    AppendInstruction(ILInstructionType.Ldind, typeof(ushort));
                    return true;
                case ILOpCode.Ldind_U4:
                    AppendInstruction(ILInstructionType.Ldind, typeof(uint));
                    return true;
                case ILOpCode.Ldind_R4:
                    AppendInstruction(ILInstructionType.Ldind, typeof(float));
                    return true;
                case ILOpCode.Ldind_R8:
                    AppendInstruction(ILInstructionType.Ldind, typeof(double));
                    return true;
                case ILOpCode.Ldind_I:
                    AppendInstruction(ILInstructionType.Ldind, NativePtrType);
                    return true;
                case ILOpCode.Ldind_Ref:
                    AppendInstruction(ILInstructionType.Ldind, typeof(object));
                    return true;
                case ILOpCode.Stind_I1:
                    AppendInstruction(ILInstructionType.Stind, typeof(byte));
                    return true;
                case ILOpCode.Stind_I2:
                    AppendInstruction(ILInstructionType.Stind, typeof(short));
                    return true;
                case ILOpCode.Stind_I4:
                    AppendInstruction(ILInstructionType.Stind, typeof(int));
                    return true;
                case ILOpCode.Stind_I8:
                    AppendInstruction(ILInstructionType.Stind, typeof(long));
                    return true;
                case ILOpCode.Stind_R4:
                    AppendInstruction(ILInstructionType.Stind, typeof(float));
                    return true;
                case ILOpCode.Stind_R8:
                    AppendInstruction(ILInstructionType.Stind, typeof(double));
                    return true;
                case ILOpCode.Stind_I:
                    AppendInstruction(ILInstructionType.Stind, NativePtrType);
                    return true;
                case ILOpCode.Stind_Ref:
                    AppendInstruction(ILInstructionType.Stind, typeof(object));
                    return true;
                case ILOpCode.Localloc:
                    AppendInstruction(ILInstructionType.Localloc);
                    return true;

                // Blk
                case ILOpCode.Cpblk:
                    AppendInstruction(ILInstructionType.Cpblk);
                    return true;
                case ILOpCode.Initblk:
                    AppendInstruction(ILInstructionType.Initblk);
                    return true;

                // SizeOf
                case ILOpCode.Sizeof:
                    AppendInstruction(ILInstructionType.SizeOf, ReadTypeArg());
                    return true;

                // Token
                case ILOpCode.Ldtoken:
                    AppendInstruction(ILInstructionType.LdToken, AssociatedModule.ResolveMember(ReadIntArg(), TypeGenericArguments, MethodGenericArguments));
                    return true;

                // Function
                case ILOpCode.Ldftn:
                    AppendInstruction(ILInstructionType.LdFunction, AssociatedModule.ResolveMember(ReadIntArg(), TypeGenericArguments, MethodGenericArguments));
                    return true;
                case ILOpCode.Ldvirtftn:
                    AppendInstruction(ILInstructionType.LdVirtualFunction, AssociatedModule.ResolveMember(ReadIntArg(), TypeGenericArguments, MethodGenericArguments));
                    return true;

                // Exceptions
                case ILOpCode.Throw:
                    AppendInstruction(ILInstructionType.Throw);
                    return true;
                case ILOpCode.Rethrow:
                    AppendInstruction(ILInstructionType.Rethrow);
                    return true;
                case ILOpCode.Leave_S:
                    AppendInstruction(ILInstructionType.Leave, new ILInstructionBranchTargets(ReadShortBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Leave:
                    AppendInstruction(ILInstructionType.Leave, new ILInstructionBranchTargets(ReadBranchTarget(), _ilOffset));
                    return true;
                case ILOpCode.Endfinally:
                    AppendInstruction(ILInstructionType.EndFinally);
                    return true;

                default:
                    return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool TryDisassemblePrefix(ILOpCode opCode)
        {
            switch (opCode)
            {
                case ILOpCode.No:
                    AddFlags(ILInstructionFlags.Unchecked);
                    return true;
                case ILOpCode.Unaligned:
                    AddFlags(ILInstructionFlags.Unaligned);
                    return true;
                case ILOpCode.Volatile:
                    AddFlags(ILInstructionFlags.Volatile);
                    return true;
                case ILOpCode.Readonly:
                    AddFlags(ILInstructionFlags.ReadOnly);
                    return true;
                case ILOpCode.Tail:
                    AddFlags(ILInstructionFlags.Tail);
                    return true;
                case ILOpCode.Constrained:
                    AddFlags(ILInstructionFlags.Constrained);
                    _flagsArgument = ReadTypeArg();
                    return true;
                default:
                    return false;
            }
        }
    }
}
