// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2024-2025 ILGPU Project
//                                    www.ilgpu.net
//
// File: IntrinsicGeneration.tt/IntrinsicGeneration.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="IntrinsicsInformation.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
string rootPath = Host.ResolvePath(".");
var infos = IntrinsicsInformation.LoadAll(rootPath);
#>
using ILGPU;
using ILGPU.Util;
using ILGPUC.IR.Values;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

// disable: max_line_length

namespace ILGPUC.Frontend.Intrinsic;

partial class Intrinsics
{
<# int totalEntries = 0; #>
<# foreach (var info in infos) { #>
<#      foreach (var type in info.Types.Where(t => t.HasGeneration)) { #>
    /// <summary>
    /// Initializes remappings for type <see cref="<#= type.CommentName #>" />.
    /// </summary>
    private static void InitializeGeneration_<#= type.FunctionName #>()
    {
        static void Add(MethodBase source, IntrinsicGenerator target) =>
            _generators.Add((source.Module, source.MetadataToken), target);

        var sourceMethods = new MethodLookup(
            typeof(<#= type.ManagedTypeName #>),
            GeneratorBindingFlags);
        var targetType = typeof(<#= type.Generation.Target #>);
<#          foreach (var generator in type.Generation.Generators) { #>
        {
<#              if (generator.NumArguments > -1) { #>
            var sources = sourceMethods["<#= generator.Name #>", <#= generator.NumArguments #>];
<#              } else { #>
            var sources = sourceMethods["<#= generator.Name #>"];
<#              } #>
<#              if (generator.HasCustomArguments) { #>
            ValueReference IntrinsicWrapper(ref InvocationContext context) =>
                <#= type.Generation.Target #>.<#= generator.Target #>(
                ref context,
                <#= string.Join(", ", generator.GetArguments()) #>);
            var target = new IntrinsicGenerator(IntrinsicWrapper);
<#              } else { #>
            var target = new IntrinsicGenerator(
                <#= type.Generation.Target #>.<#= generator.Target #>);
<#              } #>
            foreach (var source in sources)
                Add(source, target);
<#              ++totalEntries; #>
        }
<#          } #>
    }

<#      } #>
<# } #>
    /// <summary>
    /// Initializes all generators.
    /// </summary>
    private static void InitializeGeneration()
    {
<# foreach (var info in infos) { #>
<#      foreach (var type in info.Types.Where(t => t.HasGeneration)) { #>
        InitializeGeneration_<#= type.FunctionName #>();
<#      } #>
<# } #>
    }

    /// <summary>
    /// Stores internal type generators.
    /// </summary>
    private static readonly Dictionary<(Module, int), IntrinsicGenerator> _generators =
        new(<#= totalEntries #>);

    /// <summary>
    /// Tries to get an intrinsic generator for the given method.
    /// </summary>
    private static bool TryGetIntrinsicGenerator(
        MethodBase methodBase,
        [NotNullWhen(true)] out IntrinsicGenerator? generator) =>
        _generators.TryGetValue(
            (methodBase.Module, methodBase.MetadataToken),
            out generator);

    /// <summary>
    /// Returns true if the given method has an intrinsic generator.
    /// </summary>
    private static bool HasIntrinsicGenerator(MethodBase methodBase) =>
        _generators.ContainsKey((methodBase.Module, methodBase.MetadataToken));
}