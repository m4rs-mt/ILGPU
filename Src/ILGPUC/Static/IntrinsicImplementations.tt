// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2024-2025 ILGPU Project
//                                    www.ilgpu.net
//
// File: IntrinsicImplementations.tt/IntrinsicImplementations.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="IntrinsicsInformation.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
string rootPath = Host.ResolvePath(".");
var infos = IntrinsicsInformation.LoadAll(rootPath);
#>
using ILGPU;
using ILGPU.Util;
using System.Collections.Generic;
using System.Reflection;

// disable: max_line_length

namespace ILGPUC.Frontend.Intrinsic;

partial class Intrinsics
{
<# int totalEntries = 0; #>
<# foreach (var info in infos) { #>
<#      foreach (var type in info.Types.Where(t => t.HasImplementations)) { #>
    /// <summary>
    /// Initializes implementations for type <see cref="<#= type.CommentName #>" />.
    /// </summary>
    private static void InitializeBackendImplementation_<#= type.FunctionName #>()
    {
        static void Add(MethodBase source, BackendMap<MethodBase> target) =>
            _implementations.Add((source.Module, source.MetadataToken), target);

        var ptxType = typeof(<#= type.Backends.PTXImplementationType #>);

        var sourceMethods = new MethodLookup(
            typeof(<#= type.ManagedTypeName #>),
            RemapBindingFlags);
<#          foreach (var impl in type.Backends) { #>
        {
            var ptxMethod = ptxType.GetMethod("<#= impl.Target #>", RemapBindingFlags);

<#          if (impl.NumArguments > -1) { #>
            var sources = sourceMethods["<#= impl.Name #>", <#= impl.NumArguments #>];
<#          } else { #>
            var sources = sourceMethods["<#= impl.Name #>"];
<#          } #>
            var map = new BackendMap<MethodBase>(
                ptxMethod.ThrowIfNull());
            foreach (var source in sources)
                Add(source, map);
<#              ++totalEntries; #>
        }
<#          } #>
    }

<#      } #>
<# } #>
    /// <summary>
    /// Initializes all implementations.
    /// </summary>
    private static void InitializeBackendImplementations()
    {
<# foreach (var info in infos) { #>
<#      foreach (var type in info.Types.Where(t => t.HasImplementations)) { #>
        InitializeBackendImplementation_<#= type.FunctionName #>();
<#      } #>
<# } #>
    }

    /// <summary>
    /// Stores internal implementation methods.
    /// </summary>
    private static readonly Dictionary<(Module, int), BackendMap<MethodBase>>
        _implementations = new(<#= totalEntries #>);

    /// <summary>
    /// Tries to get a backend implementation for the given method.
    /// </summary>
    private static bool TryGetIntrinsicImplementation(
        MethodBase methodBase,
        out BackendMap<MethodBase> implementation) =>
        _implementations.TryGetValue(
            (methodBase.Module, methodBase.MetadataToken),
            out implementation);

    /// <summary>
    /// Returns true if the given method has a backend implementation.
    /// </summary>
    private static bool HasIntrinsicImplementation(MethodBase methodBase) =>
        _implementations.ContainsKey((methodBase.Module, methodBase.MetadataToken));
}