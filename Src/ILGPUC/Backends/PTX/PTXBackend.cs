// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2018-2025 ILGPU Project
//                                    www.ilgpu.net
//
// File: PTXBackend.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

using ILGPU.Runtime;
using ILGPU.Runtime.Cuda;
using ILGPU.Util;
using ILGPUC.Backends.EntryPoints;
using ILGPUC.Backends.PTX.API;
using ILGPUC.Backends.PTX.Transformations;
using ILGPUC.Frontend;
using ILGPUC.IR;
using ILGPUC.IR.Analyses;
using ILGPUC.IR.Transformations;
using System;
using System.Text;

namespace ILGPUC.Backends.PTX;

/// <summary>
/// Specifies which PTX backend-specific features should be used.
/// </summary>
enum PTXBackendMode
{
    /// <summary>
    /// Enforces the use of the default PTX backend features.
    /// </summary>
    Default,

    /// <summary>
    /// Enables the use of enhanced PTX backend features to improve
    /// performance of the kernel programs being generated.
    /// </summary>
    Enhanced
}

/// <summary>
/// Represents a PTX (Cuda) backend.
/// </summary>
/// <remarks>
/// Constructs a new Cuda backend.
/// </remarks>
/// <param name="backendMode">The backend mode.</param>
/// <param name="architecture">The target GPU architecture.</param>
/// <param name="instructionSet">The target GPU instruction set.</param>
/// <param name="nvvmAPI">Optional NVVM API instance.</param>
sealed class PTXBackend(
    PTXBackendMode backendMode,
    CudaArchitecture architecture,
    CudaInstructionSet instructionSet,
    NvvmAPI? nvvmAPI = null) :
    Backend<PTXCodeGenerator.GeneratorArgs, PTXCodeGenerator, StringBuilder>(
        BackendType.PTX,
        AcceleratorType.Cuda,
        new CudaCapabilityContext(architecture))
{
    #region Constants

    /// <summary>
    /// Returns the warp size.
    /// </summary>
    public const int WarpSize = 32;

    /// <summary>
    /// Returns the default global memory alignment in bytes.
    /// </summary>
    /// <remarks>
    /// See Cuda documentation section 5.3.2.
    /// </remarks>
    public const int DefaultGlobalMemoryAlignment = 256;

    /// <summary>
    /// Returns the default shared memory alignment in bytes to benefit from
    /// vectorized IO operations in most cases.
    /// </summary>
    public const int DefaultSharedMemoryAlignment = 4;

    #endregion

    #region Instance

    /// <inheritdoc/>
    protected override void Dispose(bool disposing)
    {
        NvvmAPI?.Dispose();
        NvvmAPI = null;

        base.Dispose(disposing);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Returns the current architecture.
    /// </summary>
    public CudaArchitecture Architecture { get; } = architecture;

    /// <summary>
    /// Returns the current instruction set.
    /// </summary>
    public CudaInstructionSet InstructionSet { get; } = instructionSet;

    /// <summary>
    /// Returns the supported capabilities.
    /// </summary>
    public new CudaCapabilityContext Capabilities =>
        base.Capabilities.AsNotNullCast<CudaCapabilityContext>();

    /// <summary>
    /// Returns the NVVM API instance (if available).
    /// </summary>
    public NvvmAPI? NvvmAPI { get; private set; } = nvvmAPI;

    /// <summary>
    /// Returns <see cref="WarpSize"/>.
    /// </summary>
    public override int? CurrentWarpSize => WarpSize;

    #endregion

    #region Methods

    /// <summary>
    /// Creates a new PTX-compatible kernel builder and initializes a
    /// <see cref="PTXCodeGenerator.GeneratorArgs"/> instance.
    /// </summary>
    protected override StringBuilder CreateKernelBuilder(
        EntryPoint entryPoint,
        IRContext context,
        Allocations allocations,
        out PTXCodeGenerator.GeneratorArgs data)
    {
        var debugSymbolsMode = context.Properties.DebugSymbolsMode;
        PTXDebugInfoGenerator debugInfoGenerator =
            debugSymbolsMode > DebugSymbolsMode.None
            ? new PTXDebugLineInfoGenerator()
            : PTXNoDebugInfoGenerator.Empty;

        var builder = new StringBuilder();

        builder.AppendLine("//");
        builder.Append("// Generated by ILGPU v");
        builder.AppendLine(IRContext.IRVersion.ToString());
        builder.AppendLine("//");
        builder.AppendLine();

        builder.Append(".version ");
        builder.AppendLine(InstructionSet.ToString());
        builder.Append(".target ");
        builder.Append(Architecture.ToString().ToLowerInvariant());
        if (debugSymbolsMode > DebugSymbolsMode.None)
            builder.AppendLine(", debug");
        else
            builder.AppendLine();
        builder.Append(".address_size ");
        builder.AppendLine((context.PointerSize * 8).ToString());
        builder.AppendLine();

        GenerateLibDeviceCode(context, builder);

        // Check whether we are running in the O1 or O2 pipeline
        bool o1Enabled = context.Properties.OptimizationLevel >= OptimizationLevel.O1;
        bool o2Enabled = context.Properties.OptimizationLevel > OptimizationLevel.O1;

        // Get main kernel method
        var kernelMethod = context.GetMethod(entryPoint.Method);

        // Creates pointer alignment information in the context of O1 or higher
        var alignments = o1Enabled
            ? PointerAlignments.Apply(
                kernelMethod,
                DefaultGlobalMemoryAlignment)
            : PointerAlignments.AlignmentInfo.Empty;

        // Create detailed uniform information in O2 builds
        var uniforms = o2Enabled ? Uniforms.Apply(kernelMethod) : Uniforms.Info.Empty;

        data = new PTXCodeGenerator.GeneratorArgs(
            Capabilities,
            context,
            entryPoint,
            backendMode,
            allocations,
            debugInfoGenerator,
            alignments,
            uniforms);

        return builder;
    }

    /// <summary>
    /// Creates a new <see cref="PTXFunctionGenerator"/>.
    /// </summary>
    protected override PTXCodeGenerator CreateFunctionCodeGenerator(
        Method method,
        PTXCodeGenerator.GeneratorArgs data) =>
        new PTXFunctionGenerator(data, method);

    /// <summary>
    /// Creates a new <see cref="PTXFunctionGenerator"/>.
    /// </summary>
    protected override PTXCodeGenerator CreateKernelCodeGenerator(
        Method method,
        PTXCodeGenerator.GeneratorArgs data) =>
        new PTXKernelFunctionGenerator(data, method);

    /// <summary>
    /// Serializes the current kernel builder as UTF-8 string.
    /// </summary>
    protected override ReadOnlyMemory<byte> SerializeBuilder(
        StringBuilder builder,
        PTXCodeGenerator.GeneratorArgs data,
        out ReadOnlyMemory<byte> customAttributes)
    {
        data.DebugInfoGenerator.GenerateDebugSections(builder);

        customAttributes = CudaCompiledKernel.SerializeCustomAttributes(
            Architecture,
            InstructionSet);

        var baseString = builder.ToString();
        return Encoding.UTF8.GetBytes(baseString);
    }

    /// <summary>
    /// Adds custom backend optimizations and initializes PTX backend scheduling.
    /// </summary>
    protected override Transformer CreateTransformer(
        ILFrontend fronted,
        IRContext context,
        Transformer.Builder builder)
    {
        // Implement all intrinsics
        builder.AddImplementIntrinsics<PTXIntrinsicMapper, PTXIntrinsicCodeGenerator>(
            fronted);

        // Specialize intrinsics
        builder.AddAcceleratorSpecializer(this, context);

        // Implement backend optimizations
        builder.AddBackendOptimizations<CodePlacement.GroupOperands>(
            context.Properties.OptimizationLevel);

        if (backendMode == PTXBackendMode.Enhanced)
        {
            // Create an optimized PTX assembler block schedule
            builder.Add(new PTXBlockScheduling());
            builder.Add(new DeadCodeElimination());
        }

        return builder.ToTransformer();
    }

    /// <summary>
    /// Generates LibDevice code.
    /// </summary>
    /// <param name="context">The current kernel context.</param>
    /// <param name="builder">The target string builder.</param>
    private unsafe void GenerateLibDeviceCode(IRContext context, StringBuilder builder)
    {
        if (NvvmAPI is null || context.Methods.Count == 0)
            return;

        // Determine the NVVM IR Version to use.
        var result = NvvmAPI.GetIRVersion(out int majorIR, out _, out _, out _);
        if (result != NvvmResult.NVVM_SUCCESS)
            return;

        // Convert the methods in the context into NVVM.
        var nvvmModule = PTXLibDeviceNvvm.GenerateNvvm(majorIR, context.Methods);

        if (string.IsNullOrEmpty(nvvmModule))
            return;

        // Create a new NVVM program.
        result = NvvmAPI.CreateProgram(out var program);

        try
        {
            // Add custom NVVM module.
            if (result == NvvmResult.NVVM_SUCCESS)
            {
                var nvvmModuleBytes = Encoding.ASCII.GetBytes(nvvmModule);
                fixed (byte* nvvmPtr = nvvmModuleBytes)
                {
                    result = NvvmAPI.AddModuleToProgram(
                        program,
                        new IntPtr(nvvmPtr),
                        new IntPtr(nvvmModuleBytes.Length),
                        null);
                }
            }

            // Add the LibDevice bit code.
            if (result == NvvmResult.NVVM_SUCCESS)
            {
                fixed (byte* ptr = NvvmAPI.LibDeviceBytes)
                {
                    result = NvvmAPI.LazyAddModuleToProgram(
                        program,
                        new IntPtr(ptr),
                        new IntPtr(NvvmAPI.LibDeviceBytes.Length),
                        null);
                }
            }

            // Compile the NVVM into PTX for the backend architecture.
            if (result == NvvmResult.NVVM_SUCCESS)
            {
                var major = Architecture.Major;
                var minor = Architecture.Minor;
                var archOption = $"-arch=compute_{major}{minor}";
                var archOptionAscii = Encoding.ASCII.GetBytes(archOption);
                fixed (byte* archOptionPtr = archOptionAscii)
                {
                    var numOptions = 1;
                    var optionValues = stackalloc byte[sizeof(void*) * numOptions];
                    var values = (void**)optionValues;
                    values[0] = archOptionPtr;

                    result = NvvmAPI.CompileProgram(
                        program,
                        numOptions,
                        new IntPtr(values));
                }
            }

            // Extract the PTX result and comment out the initial declarations.
            if (result == NvvmResult.NVVM_SUCCESS)
            {
                result = NvvmAPI.GetCompiledResult(program, out var compiledPTX);
                if (result == NvvmResult.NVVM_SUCCESS)
                {
                    var compiledString =
                        compiledPTX.AsNotNull()
                        .Replace(".version", "//.version", StringComparison.Ordinal)
                        .Replace(".target", "//.target", StringComparison.Ordinal)
                        .Replace(
                            ".address_size",
                            "//.address_size",
                            StringComparison.Ordinal);
                    builder.Append(compiledString);
                }
            }
        }
        finally
        {
            NvvmAPI.DestroyProgram(ref program);
        }
    }

    #endregion
}
