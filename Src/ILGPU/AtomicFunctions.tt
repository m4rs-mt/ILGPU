// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2023 ILGPU Project
//                                    www.ilgpu.net
//
// File: AtomicFunctions.tt/AtomicFunctions.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="Static/TypeInformation.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var atomicSignedIntAndFloatTypes = AtomicSignedIntTypes.
    Concat(AtomicFloatTypes).ToArray();
var atomicUnsignedIntAndFloatTypes = AtomicUnsignedIntTypes.
    Concat(AtomicFloatTypes).ToArray();
#>
using ILGPU.Intrinsic;
using System.Runtime.CompilerServices;
using System.Threading;

// disable: max_line_length

namespace ILGPU;

partial class Atomic
{
    #region Add

<# foreach (var type in AtomicSignedIntTypes) { #>
    /// <summary>
    /// Atomically adds the given value and the value at the target location
    /// and returns the old value.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Add(ref <#= type.Type #> target, <#= type.Type #> value) =>
        Interlocked.Add(ref target, value) - value;

<# } #>

<# foreach (var type in atomicUnsignedIntAndFloatTypes) { #>
    /// <summary>
    /// Atomically adds the given value and the value at the target location
    /// and returns the old value.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Add(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => current + newValue,
            CompareExchange);

<# } #>

    #endregion

    #region Max

<# foreach (var type in AtomicNumericTypes) { #>
    /// <summary>
    /// Atomically computes the maximum at the target location with the given value
    /// and returns the old value that was stored at the target location.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The comparison value.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Max(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => XMath.Max(current, newValue),
            CompareExchange);

<# } #>

    #endregion

    #region Min

<# foreach (var type in AtomicNumericTypes) { #>
    /// <summary>
    /// Atomically computes the minimum at the target location with the given value
    /// and returns the old value that was stored at the target location.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The comparison value.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Min(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => XMath.Min(current, newValue),
            CompareExchange);

<# } #>

    #endregion

    #region And

<# foreach (var type in AtomicIntTypes) { #>
    /// <summary>
    /// Atomically computes the logical and of the value at the target location with
    /// the given value and returns the old value that was stored at the target
    /// location.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The comparison value.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> And(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => current & newValue,
            CompareExchange);

<# } #>

    #endregion

    #region Or

<# foreach (var type in AtomicIntTypes) { #>
    /// <summary>
    /// Atomically computes the logical or of the value at the target location with
    /// the given value and returns the old value that was stored at the target
    /// location.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The comparison value.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Or(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => current | newValue,
            CompareExchange);

<# } #>

    #endregion

    #region Xor

<# foreach (var type in AtomicIntTypes) { #>
    /// <summary>
    /// Atomically computes the logical xor of the value at the target location with
    /// the given value and returns the old value that was stored at the target
    /// location.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The comparison value.</param>
    /// <returns>The old value that was stored at the target location.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Xor(ref <#= type.Type #> target, <#= type.Type #> value) =>
        MakeAtomic(
            ref target,
            value,
            static (current, newValue) => current ^ newValue,
            CompareExchange);

<# } #>

    #endregion

    #region Exchange

<# foreach (var type in AtomicSignedIntTypes) { #>
    /// <summary>
    /// Represents an atomic exchange operation.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="value">The target value.</param>
    /// <returns>The old value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> Exchange(ref <#= type.Type #> target, <#= type.Type #> value) =>
        Interlocked.Exchange(ref target, value);

<# } #>

    #endregion

    #region Compare & Exchange

<# foreach (var type in AtomicSignedIntTypes) { #>
    /// <summary>
    /// Represents an atomic compare-exchange operation.
    /// </summary>
    /// <param name="target">The target location.</param>
    /// <param name="compare">The expected comparison value.</param>
    /// <param name="value">The target value.</param>
    /// <returns>The old value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    [AtomicIntrinsic]
    public static <#= type.Type #> CompareExchange(
        ref <#= type.Type #> target,
        <#= type.Type #> compare,
        <#= type.Type #> value) =>
        Interlocked.CompareExchange(ref target, value, compare);

<# } #>

    #endregion
}