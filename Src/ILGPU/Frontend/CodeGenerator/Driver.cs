// -----------------------------------------------------------------------------
//                                    ILGPU
//                     Copyright (c) 2016-2020 Marcel Koester
//                                www.ilgpu.net
//
// File: CodeGeneratorDriver.cs
//
// This file is part of ILGPU and is distributed under the University of
// Illinois Open Source License. See LICENSE.txt for details
// -----------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using ILGPU.IR.Construction;
using ILGPU.IR.Values;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace ILGPU.Frontend
{
    partial class CodeGenerator
    {
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private bool TryGenerateCode(Block block, IRBuilder builder, ILInstruction instruction)
        {
            switch (instruction.InstructionType)
            {
                case ILInstructionType.Nop:
                    MakeNop();
                    return true;
                case ILInstructionType.Break:
                    MakeTrap();
                    return true;
                case ILInstructionType.LdToken:
                    MakeLoadToken(block, builder, instruction.Argument);
                    return true;

                case ILInstructionType.Ldarg:
                    LoadVariable(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;
                case ILInstructionType.Ldarga:
                    LoadVariableAddress(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;
                case ILInstructionType.Starg:
                    StoreVariable(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;

                case ILInstructionType.Ldloc:
                    LoadVariable(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;
                case ILInstructionType.Ldloca:
                    LoadVariableAddress(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;
                case ILInstructionType.Stloc:
                    StoreVariable(block, builder, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;

                case ILInstructionType.LdI4:
                    Load(block, builder, instruction.GetArgumentAs<int>());
                    return true;
                case ILInstructionType.LdI8:
                    Load(block, builder, instruction.GetArgumentAs<long>());
                    return true;
                case ILInstructionType.LdR4:
                    Load(block, builder, instruction.GetArgumentAs<float>());
                    return true;
                case ILInstructionType.LdR8:
                    Load(block, builder, instruction.GetArgumentAs<double>());
                    return true;
                case ILInstructionType.Ldstr:
                    LoadString(block, builder, instruction.GetArgumentAs<string>());
                    return true;

                case ILInstructionType.Dup:
                    MakeDup(block);
                    return true;
                case ILInstructionType.Pop:
                    MakePop(block);
                    return true;
                case ILInstructionType.Ret:
                    MakeReturn(block, builder);
                    return true;
                case ILInstructionType.Call:
                    MakeCall(block, builder, instruction.GetArgumentAs<MethodBase>());
                    return true;
                case ILInstructionType.Callvirt:
                    MakeVirtualCall(block, builder, instruction);
                    return true;
                case ILInstructionType.Calli:
                    MakeCalli(instruction.Argument);
                    return true;
                case ILInstructionType.Jmp:
                    MakeJump(instruction.GetArgumentAs<MethodBase>());
                    return true;

                case ILInstructionType.Box:
                    MakeBox(block, builder);
                    return true;
                case ILInstructionType.Unbox:
                    MakeUnbox(block, builder, instruction.GetArgumentAs<Type>());
                    return true;

                case ILInstructionType.Br:
                    MakeBranch(block, builder);
                    return true;

                case ILInstructionType.Brfalse:
                    MakeBranchFalse(block, builder);
                    return true;
                case ILInstructionType.Brtrue:
                    MakeBranchTrue(block, builder);
                    return true;

                case ILInstructionType.Beq:
                    MakeBranch(block, builder, CompareKind.Equal, instruction.Flags);
                    return true;
                case ILInstructionType.Bne:
                    MakeBranch(block, builder, CompareKind.NotEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Bge:
                    MakeBranch(block, builder, CompareKind.GreaterEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Bgt:
                    MakeBranch(block, builder, CompareKind.GreaterThan, instruction.Flags);
                    return true;
                case ILInstructionType.Ble:
                    MakeBranch(block, builder, CompareKind.LessEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Blt:
                    MakeBranch(block, builder, CompareKind.LessThan, instruction.Flags);
                    return true;

                case ILInstructionType.Switch:
                    MakeSwitch(block, builder, instruction.GetArgumentAs<ILInstructionBranchTargets>());
                    return true;

                case ILInstructionType.Add:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Add, instruction);
                    return true;
                case ILInstructionType.Sub:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Sub, instruction);
                    return true;
                case ILInstructionType.Mul:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Mul, instruction);
                    return true;
                case ILInstructionType.Div:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Div, instruction);
                    return true;
                case ILInstructionType.Rem:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Rem, instruction);
                    return true;
                case ILInstructionType.And:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.And, instruction);
                    return true;
                case ILInstructionType.Or:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Or, instruction);
                    return true;
                case ILInstructionType.Xor:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Xor, instruction);
                    return true;
                case ILInstructionType.Shl:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Shl, instruction);
                    return true;
                case ILInstructionType.Shr:
                    MakeArithmetic(block, builder, BinaryArithmeticKind.Shr, instruction);
                    return true;
                case ILInstructionType.Neg:
                    MakeArithmetic(block, builder, UnaryArithmeticKind.Neg);
                    return true;
                case ILInstructionType.Not:
                    MakeArithmetic(block, builder, UnaryArithmeticKind.Not);
                    return true;

                case ILInstructionType.Conv:
                    MakeConvert(block, builder, instruction.GetArgumentAs<Type>(), instruction.Flags);
                    return true;

                case ILInstructionType.Initobj:
                    MakeInitObject(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Newobj:
                    MakeNewObject(block, builder, instruction.GetArgumentAs<MethodBase>());
                    return true;
                case ILInstructionType.Isinst:
                    MakeIsInstance(block, instruction.GetArgumentAs<Type>());
                    return true;

                case ILInstructionType.Ldfld:
                    MakeLoadField(block, builder, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldsfld:
                    MakeLoadStaticField(block, builder, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldflda:
                    MakeLoadFieldAddress(block, builder, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldsflda:
                    MakeLoadStaticFieldAddress(block, builder, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Stfld:
                    MakeStoreField(block, builder, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Stsfld:
                    MakeStoreStaticField(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;

                case ILInstructionType.Ceq:
                    MakeCompare(block, builder, CompareKind.Equal, instruction.Flags);
                    return true;
                case ILInstructionType.Cgt:
                    MakeCompare(block, builder, CompareKind.GreaterThan, instruction.Flags);
                    return true;
                case ILInstructionType.Clt:
                    MakeCompare(block, builder, CompareKind.LessThan, instruction.Flags);
                    return true;

                case ILInstructionType.Ldobj:
                case ILInstructionType.Ldind:
                    MakeLoadObject(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Stobj:
                case ILInstructionType.Stind:
                    MakeStoreObject(block, builder, instruction.GetArgumentAs<Type>());
                    return true;

                case ILInstructionType.Newarr:
                    MakeNewArray(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Ldelem:
                    MakeLoadElement(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Ldelema:
                    MakeLoadElementAddress(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Stelem:
                    MakeStoreElement(block, builder, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Ldlen:
                    MakeLoadArrayLength(block, builder);
                    return true;

                default:
                    return false;
            }
        }
    }
}
