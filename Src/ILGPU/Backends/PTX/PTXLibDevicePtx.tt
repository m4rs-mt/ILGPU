// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                           Copyright (c) 2024 ILGPU Project
//                                    www.ilgpu.net
//
// File: PTXLibDevicePtx.tt/PTXLibDevicePtx.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="../../Static/TextTransformHelpers.ttinclude" #>
<#@ include file="../../Static/TypeInformation.ttinclude" #>
<#@ include file="../../Static/CudaLibDevice.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
string rootPath = Host.ResolvePath(".");
var lib = LibDevicePtxFunctions.Load(rootPath, "../../Static/CudaLibDevicePtx.xml");
#>

using ILGPU.Runtime.Cuda;
using ILGPU.Util;
using System.Collections.Generic;
using System.Text;

// disable: max_line_length

namespace ILGPU.Backends.PTX
{
    /// <summary>
    /// Contains the pre-generated PTX for Cuda LibDevice functions.
    /// </summary>
    internal static class PTXLibDevicePtx
    {
        /// <summary>
        /// Minimum architecture required to use the pre-generated PTX.
        /// </summary>
        public static CudaArchitecture MinArchtecture { get; } =
            new CudaArchitecture(<#= lib.MinArchitectureMajor #>, <#= lib.MinArchitectureMinor #>);
            
        /// <summary>
        /// Minimum instruction set required to use the pre-generated PTX.
        /// </summary>
        public static CudaInstructionSet MinInstructionSet { get; } =
            new CudaInstructionSet(<#= lib.MinInstructionSetMajor #>, <#= lib.MinInstructionSetMinor #>);

        /// <summary>
        /// Minimum instruction set required to use the pre-generated PTX.
        /// </summary>
        public static CudaDriverVersion MinDriverVersion { get; } =
            CudaDriverVersion.FromValue(<#= lib.MinDriverVersion #>);

        #region Generated PTX

<#
    foreach (var func in lib.Functions)
    {
        PushIndent(2);
        WriteLibDeviceFunctionPtx(func);
        PopIndent();
    }

#>
        #endregion

        private static readonly Dictionary<string, string> fragments =
            new Dictionary<string, string>()
            {
<#
    PushIndent(4);
    foreach (var func in lib.Functions)
        WriteLine($"{{ \"{func.Name}\", {func.Name} }},");
    PopIndent();
#>
            };
            
        private static readonly Dictionary<string, string> headers =
            new Dictionary<string, string>()
            {
<#
    PushIndent(4);
    foreach (var func in lib.Functions)
        WriteLine($"{{ \"{func.Name}\", {func.Name}{DeclarationSuffix} }},");
    PopIndent();
#>
            };

        /// <summary>
        /// Returns the pre-generated PTX code for the Cuda LibDevice functions.
        /// </summary>
        /// <param name="methods">The LibDevice method names.</param>
        /// <param name="ptxModules">Filled in with the PTX modules.</param>
        /// <param name="ptxDeclarations">Filled in with the PTX declarations.</param>
        /// <returns>The PTX modules.</returns>
        public static void GetPtx(
            IEnumerable<string> methods,
            ref InlineList<string> ptxModules,
            out string ptxDeclarations)
        {
            var declarationBuilder = new StringBuilder();

            foreach (var methodName in methods)
            {
                if (fragments.TryGetValue(methodName, out var methodPtx))
                {
                    if (headers.TryGetValue(methodName, out var header))
                        declarationBuilder.AppendLine(header);
                    ptxModules.Add(methodPtx);
                }
            }

            ptxDeclarations = declarationBuilder.ToString();
        }
    }
}
<#+

public const string DeclarationSuffix = "_decl";

void WriteLibDeviceFunctionPtx(LibDevicePtxFunction func)
{
    // PTX declaration
    WriteLine($"private const string {func.Name}{DeclarationSuffix} =");

    PopIndent();
    PopIndent();
    WriteLine("\"\"\"");

    WriteLine(func.PtxDeclaration);
    WriteLine("\"\"\";");
    WriteLine();

    PushIndent(2);

    // PTX module
    WriteLine($"private const string {func.Name} =");

    PopIndent();
    PopIndent();
    WriteLine("\"\"\"");

    WriteLine(func.PtxModule);
    WriteLine("\"\"\";");
    WriteLine();

    PushIndent();
}

[XmlRoot("LibDevicePtx")]
public class LibDevicePtxFunctions
{
    internal static LibDevicePtxFunctions Load(string rootPath, string fileName) =>
        XmlHelper.Load<LibDevicePtxFunctions>(rootPath, fileName);

    [XmlAttribute]
    public int MinArchitectureMajor { get; set; }

    [XmlAttribute]
    public int MinArchitectureMinor { get; set; }

    [XmlAttribute]
    public int MinInstructionSetMajor { get; set; }

    [XmlAttribute]
    public int MinInstructionSetMinor { get; set; }

    [XmlAttribute]
    public int MinDriverVersion { get; set; }

    [XmlElement("Function")]
    public LibDevicePtxFunction[] Functions { get; set; }
}

[XmlRoot("Function")]
public class LibDevicePtxFunction
{
    [XmlAttribute]
    public string Name { get; set; }

    [XmlAttribute]
    public string PtxModule { get; set; }

    [XmlAttribute]
    public string PtxDeclaration { get; set; }
}

#>