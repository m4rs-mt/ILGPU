<#@ template hostspecific="true" language="C#" #>
<#@ output extension=".cs"#>
<#@ include file="BuilderCommon.ttinclude"#>
<#@ assembly name="System.Core" #>
<#
    void CreateBody(int opCode, List<(SPIRVOperand operand, string name)> paramInfos)
    {
#> {
<#
        PushIndent(standardIndent);
        if (paramInfos.Count != 0)
        {
#>var tempList = new List<SPIRVWord>();
<#
        }

        foreach (var (operand, name) in paramInfos)
        {
            if (operand.Quantifier == "?")
            {
#>if(<#= name#> is <#= operand.Type#> <#= name#>NotNull)
    tempList.AddRange(<#= name#>NotNull.ToWords());
<#
            }
            else if (operand.Quantifier == "*")
            {
#>foreach(var element in <#= name #>)
{
    tempList.AddRange(element.ToWords());
}
<#
            }
            else
            {
#>tempList.AddRange(<#= name #>.ToWords());
<#
            }
        }
#>
ushort opCode = <#= opCode#>;
<#
        if (paramInfos.Count == 0)
        {
#>ushort wordCount = 0;
<#
        }
        else
        {
#>ushort wordCount = (ushort) (tempList.Count + 1);
<#
        }
#>uint combined = SPIRVBuilderUtils.JoinOpCodeWordCount(opCode, wordCount);
_instructions.Add(new SPIRVWord(combined));
<#
        if (paramInfos.Count != 0)
        {
#>_instructions.AddRange(tempList);
<#
        }
#>
<#
        PopIndent();
#>
}

<#
    }
#>
using System;
using System.Linq;
using System.Collections.Generic;
using ILGPU.Backends.SPIRV.Types;

#nullable enable

namespace ILGPU.Backends.SPIRV {

<#
    PushIndent(standardIndent);
#>
/// <summary>
/// Defines utility methods to generate SPIRV operations
/// </summary>
[CLSCompliant(false)]
public class BinarySPIRVBuilder : ISPIRVBuilder
{

    private readonly List<SPIRVWord> _instructions = new List<SPIRVWord>();

    // TODO: Potential performance concern, ok or not?
    public byte[] ToByteArray() => _instructions
        .Select(x => x.Data)
        .Select(x => BitConverter.GetBytes(x))
        .SelectMany(x => x)
        .ToArray();

    public void AddMetadata(
        SPIRVWord magic,
        SPIRVWord version,
        SPIRVWord genMagic,
        SPIRVWord bound,
        SPIRVWord schema)
    {
        _instructions.Add(magic);
        _instructions.Add(version);
        _instructions.Add(genMagic);
        _instructions.Add(bound);
        _instructions.Add(schema);
    }

    public void Merge(ISPIRVBuilder other)
    {
        if(other == null)
            throw new ArgumentNullException(nameof(other));

        if(other is BinarySPIRVBuilder otherBinary)
        {
            _instructions.AddRange(otherBinary._instructions);
            return;
        }

        throw new InvalidCodeGenerationException(
            "Attempted to merge string representation builder with binary builder"
        );
    }

<#
    PushIndent(standardIndent);
    foreach (var instruction in grammar.Instructions.Instructions)
    {
        var paramInfos = GenerateParamInfos(instruction);
        CreateHeader(instruction.OpName, paramInfos);
        CreateBody(instruction.OpCode, paramInfos);
    }
    PopIndent();
#>
}
<#
    PopIndent();
#>
}
#nullable restore