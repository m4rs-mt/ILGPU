// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2021 ILGPU Project
//                                    www.ilgpu.net
//
// File: ArrayViewExtensions.Generated.tt/ArrayViewExtensions.Generated.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="../Static/TypeInformation.ttinclude"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
// Array view instances with direct memset/copy functions
var basicFunctions = new string[]
{
    "ArrayView1D<T, Stride1D.Infinite>",
    "ArrayView1D<T, Stride1D.Dense>",
};
// Stride name, Needs transpose from/to .Net arrays
var twoDStrides = new (string, bool)[]
{
    ("DenseX", true),
    ("DenseY", false),
};
var threeDStrides = new (string, bool)[]
{
    ("DenseXY", true),
    ("DenseZY", false),
};
var dimensionStrides =
    twoDStrides.Select(t => (2, t.Item1, t.Item2)).Concat(
    threeDStrides.Select(t => (3, t.Item1, t.Item2)));
var extendedDimensionStrides =
    dimensionStrides.Concat(new [] { (1, "Dense", false) });
var generalDimensionStrides =
    extendedDimensionStrides.Concat(
        new [] {
            (1, "General", true),
            (2, "General", true),
            (3, "General", true) });
// Cast functionality
var castFunctions = new (string, string)[]
{
    ("ArrayView1D", "Stride1D.Dense"),

    ("ArrayView2D", "Stride2D.DenseX"),
    ("ArrayView2D", "Stride2D.DenseY"),

    ("ArrayView3D", "Stride3D.DenseXY"),
    ("ArrayView3D", "Stride3D.DenseZY"),
};
#>
using ILGPU.Resources;
using System;
using System.Runtime.CompilerServices;

namespace ILGPU.Runtime
{
    partial class ArrayViewExtensions
    {
        #region Cast Methods

<# foreach (var (viewName, strideName) in castFunctions) { #>
        /// <summary>
        /// Casts the given array view into another array-view type.
        /// </summary>
        /// <typeparam name="T">The current element type.</typeparam>
        /// <typeparam name="TOther">The target element type.</typeparam>
        /// <returns>The casted array view.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= viewName #><TOther, <#= strideName #>> Cast<T, TOther>(
            this <#= viewName #><T, <#= strideName #>> view)
            where T : unmanaged
            where TOther : unmanaged
        {
            var (extent, stride) = view.Stride.Cast(
                StrideExtensions.CreateCastContext(
                    ArrayView<T>.ElementSize,
                    ArrayView<TOther>.ElementSize),
                view.Extent);
            return new <#= viewName #><TOther, <#= strideName #>>(
                view.BaseView.Cast<TOther>(),
                extent,
                stride);
        }

<# } #>
        #endregion

        #region MemSet

<# // Why are these extension methods and not structure members?
   // The reason is that we might want to implement the memset functions differently
   // depending on the stride that is being used. If we implement these features via
   // structure members, we will break API contracts in the future. #>
<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Sets the contents of the given buffer to zero using the default accelerator
        /// stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSetToZero<T>(this <#= viewName #> view)
            where T : unmanaged =>
            view.BaseView.MemSetToZero();

        /// <summary>
        /// Sets the contents of the current buffer to zero.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSetToZero<T>(
            this <#= viewName #> view,
            AcceleratorStream stream)
            where T : unmanaged =>
            view.BaseView.MemSetToZero(stream);

        /// <summary>
        /// Sets the contents of the given buffer to the given byte value using the
        /// default accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="value">The value to write into the memory buffer.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSet<T>(
            this <#= viewName #> view,
            byte value)
            where T : unmanaged =>
            view.BaseView.MemSet(value);

        /// <summary>
        /// Sets the contents of the current buffer to the given byte value.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="value">The value to write into the memory buffer.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSet<T>(
            this <#= viewName #> view,
            AcceleratorStream stream,
            byte value)
            where T : unmanaged =>
            view.BaseView.MemSet(stream, value);

<# } #>
        #endregion

        #region Copy from/to Views

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyTo<T>(
            this <#= viewName #> source,
            <#= viewName #> target)
            where T : unmanaged =>
            source.BaseView.CopyTo(target.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyTo<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            in <#= viewName #> target)
            where T : unmanaged =>
            source.BaseView.CopyTo(stream, target.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFrom<T>(
            this <#= viewName #> target,
            in <#= viewName #> source)
            where T : unmanaged =>
            target.BaseView.CopyFrom(source.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFrom<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            in <#= viewName #> source)
            where T : unmanaged =>
            target.BaseView.CopyFrom(stream, source.BaseView);

<# } #>
        #endregion

        #region Copy elements to/from CPU

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the given CPU target address while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(ref cpuData, length);

        /// <summary>
        /// Copies from the source view into the given CPU target address while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(stream, ref cpuData, length);

        /// <summary>
        /// Copies from the CPU source address into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(ref cpuData, length);

        /// <summary>
        /// Copies from the CPU source address into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(stream, ref cpuData, length);

<# } #>
        #endregion

        #region Copy from/to Spans

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the given CPU data array while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="span">The CPU data target.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            in Span<T> span)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(stream, span);

        /// <summary>
        /// Copies from the CPU source span into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="span">The CPU data source.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            in ReadOnlySpan<T> span)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(stream, span);

<# } #>
        #endregion

        #region Data Allocations

<# foreach (var (dimension, strideName, needsTranspose) in dimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator
        /// using the default stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static 
            MemoryBuffer<#= dimension #>D<T, <#= strideTypeName #>.<#= strideName #>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged =>
            Allocate<#= dimension #>D<#= strideName #><T>(
                accelerator,
                accelerator.DefaultStream,
                data);

        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static 
            MemoryBuffer<#= dimension #>D<T, <#= strideTypeName #>.<#= strideName #>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            AcceleratorStream stream,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged
        {
            if (accelerator is null)
                throw new ArgumentNullException(nameof(accelerator));
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
            {
                return new MemoryBuffer<#= dimension #>D
                    <T, <#= strideTypeName #>.<#= strideName #>>(
                    accelerator,
                    <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>.Empty);
            }

            // Allocate the raw buffer
            var extent = new LongIndex<#= dimension #>D(
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"data.GetLength({t})")) #>);
            var buffer = accelerator
                .Allocate<#= dimension #>D<#= strideName #><T>(extent);

            // Copy the data
            buffer.View.CopyFromCPU(stream, data);

            return buffer;
        }

<# } #>

        #endregion

        #region Copy to/from arrays

<# foreach (var (dimension, strideName, needsTranspose) in extendedDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayDimExpr = string.Join(",",
            Enumerable.Repeat(string.Empty, dimension)); #>
<#      var arrayType = $"T[{arrayDimExpr}]"; #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyToCPU(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the given accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static unsafe void CopyToCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
<#      if (needsTranspose) { #>
            => view.AsGeneral().CopyToCPU(stream, data);
<#      } else { #>
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
                return;
<#      if (dimension > 1) { #>
            // Check if we need to transpose the output on the CPU
            if (view.Extent.Y % view.Stride.XStride != 0
<#          if (dimension > 2) { #>
                && view.Extent.Z % (view.Stride.XStride / view.Stride.YStride) != 0
<#          } #>
                )
            {
                throw new NotSupportedException(
                    RuntimeErrorMessages.NotSupportedEfficientStrideCopy);
            }
<#      } #>
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var propertyName = IndexDimensions[i].PropertyName; #>
            if (data.GetLength(<#= i #>) <
                view.Extent.<#= IndexDimensions[i].PropertyName #>)
            {
                throw new ArgumentOutOfRangeException(nameof(data));
            }
<#      } #>

            fixed (T* ptr = data)
            {
                view.BaseView.CopyToCPU(
                    stream,
                    new Span<T>(ptr, data.Length));
            }
        }
<#      } #>

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyFromCPU(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the given stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static unsafe void CopyFromCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
<#      if (needsTranspose) { #>
            => view.AsGeneral().CopyFromCPU(stream, data);
<#      } else { #>
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (view.HasNoData())
                return;
<#      if (dimension > 1) { #>
            // Check if we need to transpose the output on the CPU
            if (view.Extent.Y % view.Stride.XStride != 0
<#          if (dimension > 2) { #>
                && view.Extent.Z % (view.Stride.XStride / view.Stride.YStride) != 0
<#          } #>
                )
            {
                throw new NotSupportedException(
                    RuntimeErrorMessages.NotSupportedEfficientStrideCopy);
            }
<#      } #>
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var propertyName = IndexDimensions[i].PropertyName; #>
            if (data.GetLength(<#= i #>) <
                view.Extent.<#= IndexDimensions[i].PropertyName #>)
            {
                throw new ArgumentOutOfRangeException(nameof(data));
            }
<#      } #>

            var tempBuffer = data;
            fixed (T* ptr = tempBuffer)
            {
                view.BaseView.CopyFromCPU(
                    stream,
                    new ReadOnlySpan<T>(ptr, tempBuffer.Length));
            }
        }
<#      } #>

<# } #>

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayDimExpr = string.Join(",",
            Enumerable.Repeat(string.Empty, dimension)); #>
<#      var arrayType = $"T[{arrayDimExpr}]"; #>

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyToCPU(data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the given accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyToCPU(stream, data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D buffer using the default accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyFromCPU(data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D buffer using the given accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyFromCPU(data);

<# } #>

        #endregion

        #region Copy to/from Page Locked

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the given page locked memory without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="pageLockScope">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToPageLockedAsync<T>(
            this <#= viewName #> source,
            PageLockScope<T> pageLockScope)
            where T : unmanaged =>
            source.BaseView.CopyToPageLockedAsync(pageLockScope);

        /// <summary>
        /// Copies from the source view into the given page locked memory without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="pageLockScope">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToPageLockedAsync<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            PageLockScope<T> pageLockScope)
            where T : unmanaged =>
            source.BaseView.CopyToPageLockedAsync(stream, pageLockScope);

        /// <summary>
        /// Copies from the page locked memory into the given target view without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="pageLockScope">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromPageLockedAsync<T>(
            this <#= viewName #> target,
            PageLockScope<T> pageLockScope)
            where T : unmanaged =>
            target.BaseView.CopyFromPageLockedAsync(pageLockScope);

        /// <summary>
        /// Copies from the page locked memory into the given target view without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="pageLockScope">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromPageLockedAsync<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            PageLockScope<T> pageLockScope)
            where T : unmanaged =>
            target.BaseView.CopyFromPageLockedAsync(stream, pageLockScope);

<# } #>
        #endregion

        #region Copy to/from Page Locked Array

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      if (needsTranspose) continue; #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Copies from the source view into the given page locked memory without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="pageLockedArray">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        /// <remarks>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToPageLockedAsync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> source,
            PageLockedArray<#= dimension #>D<T> pageLockedArray)
            where T : unmanaged =>
            source.CopyToPageLockedAsync(source.GetDefaultStream(), pageLockedArray);

        /// <summary>
        /// Copies from the source view into the given page locked memory without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="pageLockedArray">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        /// <remarks>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyToPageLockedAsync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> source,
            AcceleratorStream stream,
            PageLockedArray<#= dimension #>D<T> pageLockedArray)
            where T : unmanaged =>
            source.BaseView.CopyToPageLockedAsync(stream, pageLockedArray);

        /// <summary>
        /// Copies from the page locked memory into the given target view without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="pageLockedArray">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        /// <remarks>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromPageLockedAsync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> target,
            PageLockedArray<#= dimension #>D<T> pageLockedArray)
            where T : unmanaged =>
            target.CopyFromPageLockedAsync(target.GetDefaultStream(), pageLockedArray);

        /// <summary>
        /// Copies from the page locked memory into the given target view without
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="pageLockedArray">The page locked memory.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CopyFromPageLockedAsync<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> target,
            AcceleratorStream stream,
            PageLockedArray<#= dimension #>D<T> pageLockedArray)
            where T : unmanaged =>
            target.BaseView.CopyFromPageLockedAsync(stream, pageLockedArray);

<# } #>
        #endregion

        #region GetAsPageLocked

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      if (needsTranspose) continue; #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// page locked <#= dimension #>D array.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PageLockedArray<#= dimension #>D<T>
            GetAsPageLocked<#= dimension #>D<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view)
            where T : unmanaged =>
            view.GetAsPageLocked<#= dimension #>D(view.GetDefaultStream());

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// page locked <#= dimension #>D array.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static PageLockedArray<#= dimension #>D<T>
            GetAsPageLocked<#= dimension #>D<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream)
            where T : unmanaged
        {
            if (view.HasNoData())
                return PageLockedArray<#= dimension #>D<T>.Empty;

            // Allocate the return array
            var result = view
                .GetAccelerator()
                .AllocatePageLocked<#= dimension #>D<T>(view.Extent);

            // Copy the data
            view.CopyToPageLockedAsync(stream, result);
            stream.Synchronize();

            return result;
        }

<# } #>

        #endregion

        #region GetAsArray

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayExpr = string.Join(",", Enumerable.Repeat(string.Empty, dimension)); #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T[<#= arrayExpr #>] GetAsArray<#= dimension #>D<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view)
            where T : unmanaged =>
            view.GetAsArray<#= dimension #>D(view.GetDefaultStream());

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static T[<#= arrayExpr #>] GetAsArray<#= dimension #>D<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream)
            where T : unmanaged
        {
            if (view.HasNoData())
            {
                return new T[<#= string.Join(
                    ", ",
                    Enumerable.Repeat("0", dimension)) #>];
            }

            // Allocate the return array
            var result = new T[
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"view.Extent.{IndexDimensions[t].PropertyName}")) #>];

            // Copy the data
            view.CopyToCPU(stream, result);

            return result;
        }

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static T[<#= arrayExpr #>] GetAsArray<#= dimension #>D<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer)
            where T : unmanaged =>
            buffer.View.GetAsArray<#= dimension #>D();

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static T[<#= arrayExpr #>] GetAsArray<#= dimension #>D<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream)
            where T : unmanaged =>
            buffer.View.GetAsArray<#= dimension #>D(stream);

<# } #>

        #endregion
    }
}