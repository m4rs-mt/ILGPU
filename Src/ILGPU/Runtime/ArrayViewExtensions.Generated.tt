// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2020 Marcel Koester
//                                    www.ilgpu.net
//
// File: ArrayViewExtensions.Generated.tt/ArrayViewExtensions.Generated.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details.
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="../Static/TypeInformation.ttinclude"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
// Array view instances with direct memset/copy functions
var basicFunctions = new string[]
{
    "ArrayView1D<T, Stride1D.Infinite>",
    "ArrayView1D<T, Stride1D.Dense>",
};
// Stride name, Needs transpose from/to .Net arrays
var twoDStrides = new (string, bool)[]
{
    ("DenseX", true),
    ("DenseY", false),
};
var threeDStrides = new (string, bool)[]
{
    ("DenseXY", true),
    ("DenseZY", false),
};
var dimensionStrides =
    twoDStrides.Select(t => (2, t.Item1, t.Item2)).Concat(
    threeDStrides.Select(t => (3, t.Item1, t.Item2)));
var generalDimensionStrides =
    dimensionStrides.Concat(
        new [] {
            (1, "Dense", false),
            (1, "General", true),
            (2, "General", true),
            (3, "General", true) });
// Cast functionality
var castFunctions = new (string, string)[]
{
    ("ArrayView1D", "Stride1D.Dense"),

    ("ArrayView2D", "Stride2D.DenseX"),
    ("ArrayView2D", "Stride2D.DenseY"),

    ("ArrayView3D", "Stride3D.DenseXY"),
    ("ArrayView3D", "Stride3D.DenseZY"),
};
#>
using System;
using System.Runtime.CompilerServices;

namespace ILGPU.Runtime
{
    partial class ArrayViewExtensions
    {
        #region Cast Methods

<# foreach (var (viewName, strideName) in castFunctions) { #>
        /// <summary>
        /// Casts the given array view into another array-view type.
        /// </summary>
        /// <typeparam name="T">The current element type.</typeparam>
        /// <typeparam name="TOther">The target element type.</typeparam>
        /// <returns>The casted array view.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= viewName #><TOther, <#= strideName #>> Cast<T, TOther>(
            this <#= viewName #><T, <#= strideName #>> view)
            where T : unmanaged
            where TOther : unmanaged
        {
            var (extent, stride) = view.Stride.Cast(
                StrideExtensions.CreateCastContext(
                    ArrayView<T>.ElementSize,
                    ArrayView<TOther>.ElementSize),
                view.Extent);
            return new <#= viewName #><TOther, <#= strideName #>>(
                view.BaseView.Cast<TOther>(),
                extent,
                stride);
        }

<# } #>
        #endregion

        #region MemSet

<# // Why are these extension methods and not structure members?
   // The reason is that we might want to implement the memset functions differently
   // depending on the stride that is being used. If we implement these features via
   // structure members, we will break API contracts in the future. #>
<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Sets the contents of the given buffer to zero using the default accelerator
        /// stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSetToZero<T>(this <#= viewName #> view)
            where T : unmanaged =>
            view.BaseView.MemSetToZero();

        /// <summary>
        /// Sets the contents of the current buffer to zero.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSetToZero<T>(
            this <#= viewName #> view,
            AcceleratorStream stream)
            where T : unmanaged =>
            view.BaseView.MemSetToZero(stream);

        /// <summary>
        /// Sets the contents of the given buffer to the given byte value using the
        /// default accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="value">The value to write into the memory buffer.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSet<T>(
            this <#= viewName #> view,
            byte value)
            where T : unmanaged =>
            view.BaseView.MemSet(value);

        /// <summary>
        /// Sets the contents of the current buffer to the given byte value.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="view">The view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="value">The value to write into the memory buffer.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void MemSet<T>(
            this <#= viewName #> view,
            AcceleratorStream stream,
            byte value)
            where T : unmanaged =>
            view.BaseView.MemSet(stream, value);

<# } #>
        #endregion

        #region Copy from/to Views

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyTo<T>(
            this <#= viewName #> source,
            <#= viewName #> target)
            where T : unmanaged =>
            source.BaseView.CopyTo(target.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyTo<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            in <#= viewName #> target)
            where T : unmanaged =>
            source.BaseView.CopyTo(stream, target.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="target">The target view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFrom<T>(
            this <#= viewName #> target,
            in <#= viewName #> source)
            where T : unmanaged =>
            target.BaseView.CopyFrom(source.BaseView);

        /// <summary>
        /// Copies from the source view into the target view.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source view instance.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFrom<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            in <#= viewName #> source)
            where T : unmanaged =>
            target.BaseView.CopyFrom(stream, source.BaseView);

<# } #>
        #endregion

        #region Copy elements to/from CPU

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the given CPU target address while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            out T cpuData,
            long length)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(out cpuData, length);

        /// <summary>
        /// Copies from the source view into the given CPU target address while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            out T cpuData,
            long length)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(stream, out cpuData, length);

        /// <summary>
        /// Copies from the CPU source address into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(ref cpuData, length);

        /// <summary>
        /// Copies from the CPU source address into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="cpuData">The base address of the CPU buffer.</param>
        /// <param name="length">The number of elements to copy.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            ref T cpuData,
            long length)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(stream, ref cpuData, length);

<# } #>
        #endregion

        #region Copy from/to Spans

<# foreach (var viewName in basicFunctions) { #>
        /// <summary>
        /// Copies from the source view into the given CPU data array while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="source">The source view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="span">The CPU data target.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this <#= viewName #> source,
            AcceleratorStream stream,
            in Span<T> span)
            where T : unmanaged =>
            source.BaseView.CopyToCPU(stream, span);

        /// <summary>
        /// Copies from the CPU source span into the given target view while
        /// synchronizing the current accelerator stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="target">The target view instance.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="span">The CPU data source.</param>
        /// <remarks>This method is not supported on accelerators.</remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this <#= viewName #> target,
            AcceleratorStream stream,
            in ReadOnlySpan<T> span)
            where T : unmanaged =>
            target.BaseView.CopyFromCPU(stream, span);

<# } #>
        #endregion

        #region Data Allocations

<# foreach (var (dimension, strideName, needsTranspose) in dimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator
        /// using the default stream.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static 
            MemoryBuffer<#= dimension #>D<T, <#= strideTypeName #>.<#= strideName #>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged =>
            Allocate<#= dimension #>D<#= strideName #><T>(
                accelerator,
                accelerator.DefaultStream,
                data);

        /// <summary>
        /// Allocates a buffer with the specified content on the given accelerator.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The parent accelerator.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The source CPU data.</param>
        /// <returns>An allocated buffer on this accelerator.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static 
            MemoryBuffer<#= dimension #>D<T, <#= strideTypeName #>.<#= strideName #>>
            Allocate<#= dimension #>D<#= strideName #><T>(
            this Accelerator accelerator,
            AcceleratorStream stream,
            T[<#= string.Join(",", Enumerable.Repeat(string.Empty, dimension)) #>] data)
            where T : unmanaged
        {
            if (accelerator is null)
                throw new ArgumentNullException(nameof(accelerator));
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
            {
                return new MemoryBuffer<#= dimension #>D
                    <T, <#= strideTypeName #>.<#= strideName #>>(
                    accelerator,
                    <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>.Empty);
            }

            // Allocate the raw buffer
            var extent = new LongIndex<#= dimension #>D(
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"data.GetLength({t})")) #>);
            var buffer = accelerator.
                Allocate<#= dimension #>D<#= strideName #><T>(extent);

            // Copy the data
            buffer.View.CopyFromCPU(stream, data);

            return buffer;
        }

<# } #>

        #endregion

        #region Copy to/from arrays

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayDimExpr = string.Join(",",
            Enumerable.Repeat(string.Empty, dimension)); #>
<#      var arrayType = $"T[{arrayDimExpr}]"; #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyToCPU(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the given accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static unsafe void CopyToCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (data.Length < 1)
                return;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var propertyName = IndexDimensions[i].PropertyName; #>
            if (data.GetLength(<#= i #>) <
                view.Extent.<#= IndexDimensions[i].PropertyName #>)
            {
                throw new ArgumentOutOfRangeException(nameof(data));
            }
<#      } #>

<#      if (!needsTranspose) { #>
            fixed (T* ptr = data)
            {
                view.BaseView.CopyToCPU(
                    stream,
                    new Span<T>(ptr, data.Length));
            }
<#      } else { #>
            var tempBuffer = new T[
                <#= string.Join(", ",
                    Enumerable.Range(0, dimension)
                    .Select(t => $"data.GetLength({t})")) #>];
            fixed (T* ptr = tempBuffer)
            {
                var span = new Span<T>(ptr, tempBuffer.Length);
                view.BaseView.CopyToCPU(stream, span);

                // Transpose the input elements and store them in the result buffer
                var extent = (Index<#= dimension #>D)view.Extent;
                var stride = view.Stride;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var fieldName = IndexDimensions[i].FieldName; #>
                for (
                    int <#= fieldName #> = 0;
                    <#= fieldName #> < extent.<#= IndexDimensions[i].PropertyName #>;
                    ++<#= fieldName #>)
                {
<#      } #>
                    var multiDimIndex = new Index<#= dimension #>D(<#= string.Join(
                        ", ",
                        IndexDimensions.Take(dimension).Select(t => t.FieldName)) #>);
                    int elementIndex = stride.ComputeElementIndex(multiDimIndex);
                    data[<#= string.Join(", ",
                        Enumerable.Range(0, dimension)
                        .Select(t => IndexDimensions[t].FieldName)) #>] =
                        span[elementIndex];
<#      for (int i = 0; i < dimension; ++i) { #>
                }
<#      } #>
            }
<#      } #>
        }

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the default accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyToCPU(data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into the given
        /// <#= dimension #>D array using the given accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyToCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyToCPU(stream, data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the default accelerator stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            <#= arrayType #> data)
            where T : unmanaged =>
            CopyFromCPU(view, view.GetDefaultStream(), data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D view using the given stream.
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static unsafe void CopyFromCPU<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            if (view.HasNoData())
                return;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var propertyName = IndexDimensions[i].PropertyName; #>
            if (data.GetLength(<#= i #>) <
                view.Extent.<#= IndexDimensions[i].PropertyName #>)
            {
                throw new ArgumentOutOfRangeException(nameof(data));
            }
<#      } #>

<#      if (needsTranspose) { #>
            var tempBuffer = new T[view.Length];
            fixed (T* ptr = data)
            {
                var span = new ReadOnlySpan<T>(ptr, data.Length);

                // Transpose the input elements and store them in the result buffer
                var extent = (Index<#= dimension #>D)view.Extent;
                var stride = view.Stride;
<#      for (int i = 0; i < dimension; ++i) { #>
<#          var fieldName = IndexDimensions[i].FieldName; #>
                for (
                    int <#= fieldName #> = 0;
                    <#= fieldName #> < extent.<#= IndexDimensions[i].PropertyName #>;
                    ++<#= fieldName #>)
                {
<#      } #>
                    int targetElementIndex = view.Stride.ComputeElementIndex(
                        new Index<#= dimension #>D(<#= string.Join(
                        ", ",
                        IndexDimensions.Take(dimension).Select(t => t.FieldName)) #>));
                    int sourceElementIndex = <#= IndexDimensions[0].FieldName #>;
<#      for (int i = 1; i < dimension; ++i) { #>
<#          var dim = IndexDimensions[i]; #>
                    sourceElementIndex *= (int)view.Extent.<#= dim.PropertyName #>;
                    sourceElementIndex += <#= dim.FieldName #>;

<#      } #>
                    tempBuffer[targetElementIndex] = span[sourceElementIndex];
<#      for (int i = 0; i < dimension; ++i) { #>
                }
<#      } #>
            }
<#      } else { #>
            var tempBuffer = data;
<#      } #>
            fixed (T* ptr = tempBuffer)
            {
                view.BaseView.CopyFromCPU(
                    stream,
                    new ReadOnlySpan<T>(ptr, tempBuffer.Length));
            }
        }

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D buffer using the default accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyFromCPU(data);

        /// <summary>
        /// Copies the contents of the <#= dimension #>D array into the given
        /// <#= dimension #>D buffer using the given accelerator stream.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="data">The target data array.</param>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static void CopyFromCPU<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream,
            <#= arrayType #> data)
            where T : unmanaged =>
            buffer.View.CopyFromCPU(data);

<# } #>

        #endregion

        #region GetAsArray

<# foreach (var (dimension, strideName, needsTranspose) in generalDimensionStrides) { #>
<#      var typeName = $"ArrayView{dimension}D"; #>
<#      var strideTypeName = $"Stride{dimension}D"; #>
<#      var arrayExpr = string.Join(",", Enumerable.Repeat(string.Empty, dimension)); #>
        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static T[<#= arrayExpr #>] GetAs<#= dimension #>DArray<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view)
            where T : unmanaged =>
            view.GetAs<#= dimension #>DArray(view.GetDefaultStream());

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="view">The source view.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        [NotInsideKernel]
        public static T[<#= arrayExpr #>] GetAs<#= dimension #>DArray<T>(
            this <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>> view,
            AcceleratorStream stream)
            where T : unmanaged
        {
            if (view.HasNoData())
                return new T[<#= string.Join(
                    ", ",
                    Enumerable.Repeat("0", dimension)) #>];

            // Allocate the return array
            var result = new T[
                <#= string.Join(
                    ", ",
                    Enumerable.Range(0, dimension).
                    Select(t => $"view.Extent.{IndexDimensions[t].PropertyName}")) #>];

            // Copy the data
            view.CopyToCPU(stream, result);

            return result;
        }

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static T[<#= arrayExpr #>] GetAs<#= dimension #>DArray<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer)
            where T : unmanaged =>
            buffer.View.GetAs<#= dimension #>DArray();

        /// <summary>
        /// Copies the contents of the <#= dimension #>D view into a new
        /// <#= dimension #>D array
<#      if (needsTranspose) { #>
        /// while transposing the input buffer on the CPU.
<#      } else { #>
        /// .
<#      } #>
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        /// <remarks>
<#      if (needsTranspose) { #>
        /// CAUTION: this method transposes the data on the CPU.
<#      } #>
        /// This method is not supported on accelerators.
        /// </remarks>
        public static T[<#= arrayExpr #>] GetAs<#= dimension #>DArray<T>(
            this MemoryBuffer<
                <#= typeName #><T, <#= strideTypeName #>.<#= strideName #>>> buffer,
            AcceleratorStream stream)
            where T : unmanaged =>
            buffer.View.GetAs<#= dimension #>DArray(stream);

<# } #>

        #endregion
    }
}