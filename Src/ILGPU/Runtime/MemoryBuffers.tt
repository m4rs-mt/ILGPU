// ---------------------------------------------------------------------------------------
//                                        ILGPU
//                        Copyright (c) 2016-2020 Marcel Koester
//                                    www.ilgpu.net
//
// File: MemoryBuffers.tt/MemoryBuffers.cs
//
// This file is part of ILGPU and is distributed under the University of Illinois Open
// Source License. See LICENSE.txt for details
// ---------------------------------------------------------------------------------------

<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="../Static/TypeInformation.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using ILGPU.Util;
using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

// disable: max_line_length

namespace ILGPU.Runtime
{
<#  foreach (var dim in IndexDimensions) { #>
<#      var dimension = dim.Dimension; #>
<#      bool isBaseBuffer = dimension == 1; #>
<#      var typeName = isBaseBuffer ? "MemoryBuffer" : $"MemoryBuffer{dimension}D"; #>
<#      var indexType = $"LongIndex{dimension}"; #>
<#      var viewTypeName = isBaseBuffer ? "ArrayView<T>" : $"ArrayView{dimension}D<T>"; #>
<#      bool obsoleteCopyMethods = dimension > 1; #>
<#      var arraySeparator = new string(Enumerable.Repeat(',', dimension - 1).ToArray()); #>
    /// <summary>
    /// Represents a <#= dimension #>D memory buffer that can be used in the scope
    /// of ILGPU runtime kernels.
    /// </summary>
    /// <typeparam name="T">The element type.</typeparam>
    /// <remarks>Members of this class are not thread safe.</remarks>
    public sealed partial class <#= typeName #><T> :
        MemoryBuffer, IMemoryBuffer<T, <#= indexType #>>
        where T : unmanaged
    {
        #region Constants

        /// <summary>
        /// Represents the size of an element in bytes.
        /// </summary>
        public static int ElementSize => MemoryBuffer<T, <#= indexType #>>.ElementSize;

        #endregion

        #region Instance

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly MemoryBuffer<T, <#= indexType #>> buffer;

        /// <summary>
        /// Initializes this memory buffer.
        /// </summary>
        /// <param name="buffer">The wrapped buffer.</param>
        internal <#= typeName #>(MemoryBuffer<T, <#= indexType #>> buffer)
            : base(buffer.Accelerator, buffer.Extent.Size, ElementSize)
        {
            this.buffer = buffer;

            // Cache local data
            NativePtr = buffer.NativePtr;
            View = buffer.View;
            Extent = buffer.Extent;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the underlying generic memory buffer.
        /// </summary>
        public MemoryBuffer<T, <#= indexType #>> Buffer => buffer;

        /// <summary>
        /// Returns an array view that can access this array.
        /// </summary>
        public <#= viewTypeName #> View { get; }

        /// <summary>
        /// Returns an array view that can access this array.
        /// </summary>
        ArrayView<T, <#= indexType #>> IMemoryBuffer<T, <#= indexType #>>.View => View;

        /// <summary>
        /// Returns the extent of this buffer.
        /// </summary>
        public <#= indexType #> Extent { get; }

        #endregion

        #region MemoryBuffer Methods

        /// <summary>
        /// Sets the contents of the current buffer to the given byte value.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="value">The value to write into the memory buffer.</param>
        /// <param name="offsetInBytes">The raw offset in bytes.</param>
        /// <param name="lengthInBytes">The raw length in bytes.</param>
        protected internal override void MemSetInternal(
            AcceleratorStream stream,
            byte value,
            long offsetInBytes,
            long lengthInBytes) =>
            buffer.MemSetInternal(
                stream,
                value,
                offsetInBytes,
                lengthInBytes);

        /// <summary>
        /// Copies the current contents into a new byte array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        public override byte[] GetAsRawArray(AcceleratorStream stream) =>
            buffer.GetAsRawArray(stream);

        /// <summary>
        /// Copies the current contents into a new byte array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="byteOffset">The offset in bytes.</param>
        /// <param name="byteExtent">The extent in bytes (number of elements).</param>
        /// <returns>A new array holding the requested contents.</returns>
        protected internal override ArraySegment<byte> GetAsRawArray(
            AcceleratorStream stream,
            long byteOffset,
            long byteExtent) =>
            buffer.GetAsRawArray(stream, byteOffset, byteExtent);

        /// <summary>
        /// Copies the current contents into a new array using
        /// the default accelerator stream.
        /// </summary>
        /// <returns>A new array holding the requested contents.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T[] GetAsArray() => buffer.GetAsArray();

        /// <summary>
        /// Copies the current contents into a new array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <returns>A new array holding the requested contents.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T[] GetAsArray(AcceleratorStream stream) =>
            buffer.GetAsArray(stream);

        /// <summary>
        /// Copies the current contents into a new array using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="offset">The offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        /// <returns>A new array holding the requested contents.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T[] GetAsArray(<#= indexType #> offset, <#= indexType #> extent) =>
            buffer.GetAsArray(Accelerator.DefaultStream, offset, extent);

        /// <summary>
        /// Copies the current contents into a new array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        /// <returns>A new array holding the requested contents.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T[] GetAsArray(
            AcceleratorStream stream,
            <#= indexType #> offset,
            <#= indexType #> extent) =>
            buffer.GetAsArray(stream, offset, extent);

        /// <summary>
        /// Returns the underlying generic memory buffer.
        /// </summary>
        /// <returns>The underlying generic memory buffer.</returns>
        public MemoryBuffer<T, <#= indexType #>> ToMemoryBuffer() => buffer;

        /// <summary>
        /// Returns an array view that can access this array.
        /// </summary>
        /// <returns>An array view that can access this array.</returns>
        public ArrayView<T, <#= indexType #>> ToArrayView() => View;

        #endregion

        #region View Methods

        /// <summary>
        /// Copies elements from the current buffer to the target view.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target view.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            <#= viewTypeName #> target,
            <#= indexType #> sourceOffset) =>
            buffer.CopyTo(stream, target, sourceOffset);

        /// <summary>
        /// Copies elements from the current buffer to the target view using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target view.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(<#= viewTypeName #> target, <#= indexType #> sourceOffset) =>
            buffer.CopyTo(target, sourceOffset);

        /// <summary>
        /// Copies elements from the current buffer to the target view using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target view.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            ArrayView<T, <#= indexType #>> target,
            <#= indexType #> sourceOffset) =>
            buffer.CopyTo(target, sourceOffset);

        /// <summary>
        /// Copies elements from the current buffer to the target view.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target view.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            ArrayView<T, <#= indexType #>> target,
            <#= indexType #> sourceOffset) =>
            buffer.CopyTo(stream, target, sourceOffset);

        /// <summary>
        /// Copies elements to the current buffer from the source view.
        /// </summary>
        /// <param name="source">The source view.</param>
        /// <param name="targetOffset">The target offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(<#= viewTypeName #> source, <#= indexType #> targetOffset) =>
            buffer.CopyFrom(source, targetOffset);

        /// <summary>
        /// Copies elements to the current buffer from the source view.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source view.</param>
        /// <param name="targetOffset">The target offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            <#= viewTypeName #> source,
            <#= indexType #> targetOffset) =>
            buffer.CopyFrom(stream, source, targetOffset);

        /// <summary>
        /// Copies elements to the current buffer from the source view using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source view.</param>
        /// <param name="targetOffset">The target offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            ArrayView<T, <#= indexType #>> source,
            <#= indexType #> targetOffset) =>
            buffer.CopyFrom(source, targetOffset);

        /// <summary>
        /// Copies elements to the current buffer from the source view.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source view.</param>
        /// <param name="targetOffset">The target offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            ArrayView<T, <#= indexType #>> source,
            <#= indexType #> targetOffset) =>
            buffer.CopyFrom(stream, source, targetOffset);

        #endregion

        #region Copy Methods

        /// <summary>
        /// Copies elements from the current buffer to the target buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(<#= typeName #><T> target, <#= indexType #> sourceOffset) =>
            buffer.CopyTo(target.buffer, sourceOffset);

        /// <summary>
        /// Copies elements from the current buffer to the target buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            <#= typeName #><T> target,
            <#= indexType #> sourceOffset) =>
            buffer.CopyTo(
                stream,
                target,
                sourceOffset,
                default,
                Length);

        /// <summary>
        /// Copies elements from the current buffer to the target buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#      if (obsoleteCopyMethods) { #>
        [Obsolete("Use CopyTo(<#= typeName #><T>, TIndex, TIndex, Index1) instead")]
<#      } #>
        public void CopyTo(
            <#= typeName #><T> target,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                target,
                sourceOffset,
                targetOffset,
                extent);

<#      if (obsoleteCopyMethods) { #>
        /// <summary>
        /// Copies elements from the current buffer to the target buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            <#= typeName #><T> target,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            Index1 extent) =>
            buffer.CopyTo(
                target,
                sourceOffset,
                targetOffset,
                extent);
<#      } #>

        /// <summary>
        /// Copies elements from the current buffer to the target buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#      if (obsoleteCopyMethods) { #>
        [Obsolete("Use CopyTo(AcceleratorStream, <#= typeName #><T>, TIndex, TIndex, " +
            "Index1) instead")]
<#      } #>
        public void CopyTo(
            AcceleratorStream stream,
            <#= typeName #><T> target,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                stream,
                target,
                sourceOffset,
                targetOffset,
                extent);

<#      if (obsoleteCopyMethods) { #>
        /// <summary>
        /// Copies elements from the current buffer to the target buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            <#= typeName #><T> target,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            Index1 extent) =>
            buffer.CopyTo(
                stream,
                target,
                sourceOffset,
                targetOffset,
                extent);
<#      } #>

        /// <summary>
        /// Copies a single element of this buffer to the given target variable
        /// in CPU memory using the default accelerator stream.
        /// </summary>
        /// <param name="target">The target location.</param>
        /// <param name="targetIndex">The target index.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(out T target, <#= indexType #> targetIndex) =>
            buffer.CopyTo(out target, targetIndex);

        /// <summary>
        /// Copies a single element of this buffer to the given target variable
        /// in CPU memory.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target location.</param>
        /// <param name="targetIndex">The target index.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            out T target,
            <#= indexType #> targetIndex) =>
            buffer.CopyTo(stream, out target, targetIndex);

        /// <summary>
        /// Copies the contents of this buffer into the given array using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            T[] target,
            <#= indexType #> sourceOffset,
            long targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                target,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents of this buffer into the given array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            T[] target,
            <#= indexType #> sourceOffset,
            long targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                stream,
                target,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents of this buffer into the given array using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="target">The target array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            Span<T> target,
            <#= indexType #> sourceOffset,
            long targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                target,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents of this buffer into the given array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="target">The target array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTo(
            AcceleratorStream stream,
            Span<T> target,
            <#= indexType #> sourceOffset,
            long targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyTo(
                stream,
                target,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies elements to the current buffer from the source buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source buffer.</param>
        /// <param name="targetOffset">The target offset.</param>
        public void CopyFrom(<#= typeName #><T> source, <#= indexType #> targetOffset) =>
            buffer.CopyFrom(source, targetOffset);

        /// <summary>
        /// Copies elements to the current buffer from the source buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#      if (obsoleteCopyMethods) { #>
        [Obsolete("Use CopyFrom(<#= typeName #><T>, TIndex, TIndex, Index1) instead")]
<#      } #>
        public void CopyFrom(
            <#= typeName #><T> source,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyFrom(
                source,
                sourceOffset,
                targetOffset,
                extent);

<#      if (obsoleteCopyMethods) { #>
        /// <summary>
        /// Copies elements to the current buffer from the source buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            <#= typeName #><T> source,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            LongIndex1 extent) =>
            buffer.CopyFrom(
                source,
                sourceOffset,
                targetOffset,
                extent);
<#      } #>

        /// <summary>
        /// Copies elements to the current buffer from the source buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#      if (obsoleteCopyMethods) { #>
        [Obsolete("Use CopyFrom(AcceleratorStream, <#= typeName #><T>, TIndex, TIndex, " + 
            "Index1) instead")]
<#      } #>
        public void CopyFrom(
            AcceleratorStream stream,
            <#= typeName #><T> source,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            <#= indexType #> extent) =>
            buffer.CopyFrom(
                stream,
                source,
                sourceOffset,
                targetOffset,
                extent);

<#      if (obsoleteCopyMethods) { #>
        /// <summary>
        /// Copies elements to the current buffer from the source buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source buffer.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            <#= typeName #><T> source,
            <#= indexType #> sourceOffset,
            <#= indexType #> targetOffset,
            LongIndex1 extent) =>
            buffer.CopyFrom(
                stream,
                source,
                sourceOffset,
                targetOffset,
                extent);
<#      } #>

        /// <summary>
        /// Copies elements to the current buffer from the source buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source buffer.</param>
        /// <param name="targetOffset">The target offset.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            <#= typeName #><T> source,
            <#= indexType #> targetOffset) =>
            buffer.CopyFrom(
                stream,
                source,
                targetOffset);

        /// <summary>
        /// Copies a single element from CPU memory to this buffer using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source value.</param>
        /// <param name="sourceIndex">The source index.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(T source, <#= indexType #> sourceIndex) =>
            buffer.CopyFrom(source, sourceIndex);

        /// <summary>
        /// Copies a single element from CPU memory to this buffer.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source value.</param>
        /// <param name="sourceIndex">The source index.</param>
        public void CopyFrom(
            AcceleratorStream stream,
            T source,
            <#= indexType #> sourceIndex) =>
            buffer.CopyFrom(
                stream,
                source,
                sourceIndex);

        /// <summary>
        /// Copies the contents to this buffer from the given array using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            T[] source,
            long sourceOffset,
            <#= indexType #> targetOffset,
            long extent) =>
            buffer.CopyFrom(
                source,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents to this buffer from the given array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            T[] source,
            long sourceOffset,
            <#= indexType #> targetOffset,
            long extent) =>
            buffer.CopyFrom(
                stream,
                source,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents to this buffer from the given array using
        /// the default accelerator stream.
        /// </summary>
        /// <param name="source">The source array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            ReadOnlySpan<T> source,
            long sourceOffset,
            <#= indexType #> targetOffset,
            long extent) =>
            buffer.CopyFrom(
                source,
                sourceOffset,
                targetOffset,
                extent);

        /// <summary>
        /// Copies the contents to this buffer from the given array.
        /// </summary>
        /// <param name="stream">The used accelerator stream.</param>
        /// <param name="source">The source array.</param>
        /// <param name="sourceOffset">The source offset.</param>
        /// <param name="targetOffset">The target offset.</param>
        /// <param name="extent">The extent (number of elements).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(
            AcceleratorStream stream,
            ReadOnlySpan<T> source,
            long sourceOffset,
            <#= indexType #> targetOffset,
            long extent) =>
            buffer.CopyFrom(
                stream,
                source,
                sourceOffset,
                targetOffset,
                extent);

        #endregion

        #region Operators

        /// <summary>
        /// Implicitly converts this buffer into an array view.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        public static implicit operator <#= viewTypeName #>(<#= typeName #><T> buffer) =>
            buffer.View;

        /// <summary>
        /// Implicitly converts this buffer into an array view.
        /// </summary>
        /// <param name="buffer">The source buffer.</param>
        public static implicit operator MemoryBuffer<T, <#= indexType #>>(<#= typeName #><T> buffer) =>
            buffer.buffer;

        #endregion

        #region IDisposable

        /// <summary cref="DisposeBase.Dispose(bool)"/>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
                buffer.Dispose();
            base.Dispose(disposing);
        }

        #endregion
    }

    public partial class MemoryBufferExtensions
    {
        /// <summary>
        /// Allocates a <#= dimension #>D memory buffer with the given content on the
        /// associated accelerator.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The current accelerator.</param>
        /// <param name="data">The initial data array.</param>
        /// <returns>The allocated memory buffer.</returns>
<#      if (dimension > 1) { #>
        [SuppressMessage(
            "Microsoft.Performance",
            "CA1814: PreferJaggedArraysOverMultidimensional",
            Target = "data")]
<#      } #>
<#      var allocExpression = Enumerable.Range(0, dimension).
            Select(t => $"data.GetLongLength({t})"); #>
        public static <#= typeName #><T> Allocate<T>(
            this Accelerator accelerator,
            T[<#= arraySeparator #>] data)
            where T : unmanaged
        {
            if (data is null)
                throw new ArgumentNullException(nameof(data));
            var buffer = accelerator.Allocate<T>(<#= string.Join(", ", allocExpression) #>);
            buffer.CopyFrom(data, <#= indexType #>.Zero, <#= indexType #>.Zero, buffer.Extent);
            return buffer;
        }

<#      if (dimension == 1) { #>
        /// <summary>
        /// Allocates a <#= dimension #>D memory buffer with the given content on the
        /// associated accelerator.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The current accelerator.</param>
        /// <param name="data">The initial data array.</param>
        /// <returns>The allocated memory buffer.</returns>
        public static <#= typeName #><T> Allocate<T>(
            this Accelerator accelerator,
            ReadOnlySpan<T> data)
            where T : unmanaged
        {
            var buffer = accelerator.Allocate<T>(data.Length);
            buffer.CopyFrom(data, <#= indexType #>.Zero, <#= indexType #>.Zero, buffer.Extent);
            return buffer;
        }
<#      } #>

        /// <summary>
        /// Allocates a <#= dimension #>D memory buffer on the associated accelerator that
        /// is initialized with 0-byte values.
        /// </summary>
        /// <typeparam name="T">The element type.</typeparam>
        /// <param name="accelerator">The current accelerator.</param>
        /// <param name="extent">The extent (number of elements to allocate).</param>
        /// <returns>The allocated memory buffer.</returns>
        public static <#= typeName #><T> AllocateZero<T>(
            this Accelerator accelerator,
            <#= indexType #> extent)
            where T : unmanaged
        {
            var buffer = accelerator.Allocate<T>(extent);
            buffer.MemSetToZero();
            return buffer;
        }
    }

<#  } #>
}